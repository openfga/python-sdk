"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

import json

from unittest.mock import AsyncMock, MagicMock

import pytest

from openfga_sdk.exceptions import (
    ApiException,
    ForbiddenException,
    NotFoundException,
    RateLimitExceededError,
    ServiceException,
    UnauthorizedException,
    ValidationException,
)
from openfga_sdk.rest import RestClient, RestClientResponse


@pytest.mark.asyncio
async def test_RestClientResponse_init():
    mock_resp = MagicMock()
    mock_resp.status = 200
    mock_resp.reason = "OK"

    resp_data = b'{"test":"data"}'
    rest_resp = RestClientResponse(
        response=mock_resp, data=resp_data, status=200, reason="OK"
    )

    assert rest_resp.status == 200
    assert rest_resp.reason == "OK"
    assert rest_resp.data == resp_data
    assert rest_resp.response == mock_resp


def test_RestClientResponse_getheaders():
    mock_resp = MagicMock()
    mock_resp.headers = {"Content-Type": "application/json", "X-Testing": "true"}
    rest_resp = RestClientResponse(
        response=mock_resp, data=b"", status=200, reason="OK"
    )
    headers = rest_resp.headers
    assert headers["Content-Type"] == "application/json"
    assert headers["X-Testing"] == "true"


def test_RestClientResponse_getheader():
    mock_resp = MagicMock()
    mock_resp.headers = {"Content-Type": "application/json"}
    rest_resp = RestClientResponse(
        response=mock_resp, data=b"", status=200, reason="OK"
    )
    val = rest_resp.header("Content-Type")
    missing = rest_resp.header("X-Not-Here", default="fallback")
    assert val == "application/json"
    assert missing == "fallback"


@pytest.mark.asyncio
async def test_build_request_json_body():
    mock_config = MagicMock()
    mock_config.ssl_ca_cert = None
    mock_config.cert_file = None
    mock_config.key_file = None
    mock_config.verify_ssl = True
    mock_config.connection_pool_size_max = 4
    mock_config.proxy = None
    mock_config.proxy_headers = None
    mock_config.timeout = 5000

    client = RestClient(configuration=mock_config)
    req_args = client.build_request(
        method="POST",
        url="http://example.com/test",
        body={"foo": "bar"},
        headers={"Content-Type": "application/json"},
    )
    assert req_args.method == "POST"
    assert req_args.url == "http://example.com/test"
    assert req_args.headers["Content-Type"] == "application/json"
    assert json.loads(req_args.body) == {"foo": "bar"}


@pytest.mark.asyncio
async def test_build_request_form_data():
    mock_config = MagicMock()
    mock_config.ssl_ca_cert = None
    mock_config.cert_file = None
    mock_config.key_file = None
    mock_config.verify_ssl = True
    mock_config.connection_pool_size_max = 4
    mock_config.proxy = None
    mock_config.proxy_headers = None
    mock_config.timeout = 5000

    client = RestClient(configuration=mock_config)
    req_args = client.build_request(
        method="POST",
        url="http://example.com/upload",
        post_params=[("file", ("filename.txt", b"contents", "text/plain"))],
        headers={"Content-Type": "multipart/form-data"},
    )
    assert req_args.method == "POST"
    assert req_args.url == "http://example.com/upload"
    assert "Content-Type" not in req_args.headers


@pytest.mark.asyncio
async def test_handle_response_exception_success():
    mock_config = MagicMock()
    mock_config.ssl_ca_cert = None
    mock_config.cert_file = None
    mock_config.key_file = None
    mock_config.verify_ssl = True
    mock_config.connection_pool_size_max = 4
    mock_config.proxy = None
    mock_config.proxy_headers = None
    mock_config.timeout = 5000

    client = RestClient(configuration=mock_config)
    mock_response = MagicMock()
    mock_response.status = 200
    client._handle_response_exception(mock_response)


@pytest.mark.parametrize(
    "status, exc",
    [
        (400, ValidationException),
        (401, UnauthorizedException),
        (403, ForbiddenException),
        (404, NotFoundException),
        (429, RateLimitExceededError),
        (500, ServiceException),
        (418, ApiException),
    ],
)
@pytest.mark.asyncio
async def test_handle_response_exception_error(status, exc):
    mock_config = MagicMock()
    mock_config.ssl_ca_cert = None
    mock_config.cert_file = None
    mock_config.key_file = None
    mock_config.verify_ssl = True
    mock_config.connection_pool_size_max = 4
    mock_config.proxy = None
    mock_config.proxy_headers = None
    mock_config.timeout = 5000

    client = RestClient(configuration=mock_config)
    mock_response = MagicMock()
    mock_response.status = status

    with pytest.raises(exc):
        client._handle_response_exception(mock_response)


@pytest.mark.asyncio
async def test_close():
    mock_config = MagicMock()
    mock_config.ssl_ca_cert = None
    mock_config.cert_file = None
    mock_config.key_file = None
    mock_config.verify_ssl = True
    mock_config.connection_pool_size_max = 4
    mock_config.proxy = None
    mock_config.proxy_headers = None
    mock_config.timeout = 5000

    client = RestClient(configuration=mock_config)

    mock_session = MagicMock()
    mock_session.close = AsyncMock()
    client.pool_manager = mock_session

    await client.close()

    mock_session.close.assert_awaited_once()


@pytest.mark.asyncio
async def test_stream_happy_path():
    mock_config = MagicMock()
    mock_config.ssl_ca_cert = None
    mock_config.cert_file = None
    mock_config.key_file = None
    mock_config.verify_ssl = True
    mock_config.connection_pool_size_max = 4
    mock_config.proxy = None
    mock_config.proxy_headers = None
    mock_config.timeout = 5000

    client = RestClient(configuration=mock_config)
    mock_session = MagicMock()
    client.pool_manager = mock_session

    class FakeContent:
        async def iter_chunks(self):
            yield (b'{"foo":"bar"}\n{"hello":"world"}', None)

    mock_response = MagicMock()
    mock_response.status = 200
    mock_response.reason = "OK"
    mock_response.data = None
    mock_response.content = FakeContent()

    mock_context_manager = AsyncMock()
    mock_context_manager.__aenter__.return_value = mock_response
    mock_context_manager.__aexit__.return_value = None

    mock_session.request.return_value = mock_context_manager

    client._handle_response_exception = AsyncMock()
    client.close = AsyncMock()

    results = []
    async for item in client.stream("GET", "http://example.com"):
        results.append(item)

    assert results == [{"foo": "bar"}, {"hello": "world"}]

    client._handle_response_exception.assert_awaited_once()
    mock_response.release.assert_called_once()
    client.close.assert_awaited_once()


@pytest.mark.asyncio
async def test_stream_exception_in_chunks():
    mock_config = MagicMock()
    mock_config.ssl_ca_cert = None
    mock_config.cert_file = None
    mock_config.key_file = None
    mock_config.verify_ssl = True
    mock_config.connection_pool_size_max = 4
    mock_config.proxy = None
    mock_config.proxy_headers = None
    mock_config.timeout = 5000

    client = RestClient(configuration=mock_config)
    mock_session = MagicMock()
    client.pool_manager = mock_session

    class FakeContent:
        async def iter_chunks(self):
            raise ValueError("Boom!")

    mock_response = MagicMock()
    mock_response.status = 200
    mock_response.reason = "OK"
    mock_response.data = None
    mock_response.content = FakeContent()

    mock_context_manager = AsyncMock()
    mock_context_manager.__aenter__.return_value = mock_response
    mock_context_manager.__aexit__.return_value = None

    mock_session.request.return_value = mock_context_manager

    client._handle_response_exception = AsyncMock()
    client.close = AsyncMock()

    results = []
    async for item in client.stream("GET", "http://example.com"):
        results.append(item)

    assert results == []
    client._handle_response_exception.assert_awaited_once()
    mock_response.release.assert_called_once()
    client.close.assert_awaited_once()


@pytest.mark.asyncio
async def test_stream_partial_chunks():
    mock_config = MagicMock()
    mock_config.ssl_ca_cert = None
    mock_config.cert_file = None
    mock_config.key_file = None
    mock_config.verify_ssl = True
    mock_config.connection_pool_size_max = 4
    mock_config.proxy = None
    mock_config.proxy_headers = None
    mock_config.timeout = 5000

    client = RestClient(configuration=mock_config)
    mock_session = MagicMock()
    client.pool_manager = mock_session

    class FakeContent:
        async def iter_chunks(self):
            yield (b'{"foo":"b', None)
            yield (b'ar"}\n{"hello":"world"}', None)

    mock_response = MagicMock()
    mock_response.status = 200
    mock_response.reason = "OK"
    mock_response.data = None
    mock_response.content = FakeContent()

    mock_context_manager = AsyncMock()
    mock_context_manager.__aenter__.return_value = mock_response
    mock_context_manager.__aexit__.return_value = None

    mock_session.request.return_value = mock_context_manager

    client._handle_response_exception = AsyncMock()
    client.close = AsyncMock()

    results = []
    async for item in client.stream("GET", "http://example.com"):
        results.append(item)

    assert results == [{"foo": "bar"}, {"hello": "world"}]

    client._handle_response_exception.assert_awaited_once()
    mock_response.release.assert_called_once()
    client.close.assert_awaited_once()
