"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

import json
import logging
import socket
import ssl

from dataclasses import asdict, dataclass, fields, is_dataclass
from typing import Any

import aiohttp

from openfga_sdk.common.rest import RestClientBase, RestClientResponseProtocol
from openfga_sdk.protocols import (
    ConfigurationProtocol,
    MergeableDataclassMixin,
    RestClientRequestProtocol,
)


logger = logging.getLogger(__name__)


@dataclass
class RestClientResponse(MergeableDataclassMixin, RestClientResponseProtocol):
    response: type["aiohttp.ClientResponse"] | None = None
    data: bytes | None = None
    status: int | None = None
    reason: str | None = None

    @property
    def headers(self) -> dict[str, str]:
        return dict(self.response.headers)


class RestClient(RestClientBase):
    _connector: aiohttp.TCPConnector | None = None
    _pool_manager: aiohttp.ClientSession | None = None

    def __init__(
        self,
        configuration: ConfigurationProtocol,
        pool_size: int | None = None,
        pool_size_max: int | None = None,
        timeout: int | None = None,
        debug: bool | None = None,
    ) -> None:
        self._configuration = configuration
        self._pool_size = pool_size
        self._pool_size_max = pool_size_max
        self._timeout = timeout
        self._debug = debug

    @property
    def connector(self) -> aiohttp.TCPConnector:
        """
        Returns a configured aiohttp.TCPConnector.
        """
        if self._connector is None:
            pool_size_max = (
                self._pool_size_max or self._configuration.connection_pool_size_max
            )

            self._connector = aiohttp.TCPConnector(
                limit=pool_size_max,
                ssl=self.ssl_context,
            )

        return self._connector

    @property
    def pool_manager(self) -> aiohttp.ClientSession:
        """
        Returns a configured aiohttp.ClientSession.
        """
        if self._pool_manager is None:
            self._pool_manager = aiohttp.ClientSession(
                connector=self.connector,
                trust_env=True,
                timeout=aiohttp.ClientTimeout(total=self._timeout),
            )

        return self._pool_manager

    @pool_manager.setter
    def pool_manager(self, value: aiohttp.ClientSession) -> None:
        self._pool_manager = value

    async def close(self) -> None:
        """
        Closes the underlying aiohttp.ClientSession.
        """
        await self.pool_manager.close()

    async def stream(
        self,
        request: RestClientRequestProtocol,
        timeout: float | None = None,
    ):
        """
        Streams JSON objects from a specified endpoint, handling partial chunks
        and leftover data at the end of the stream.

        :param method: The HTTP method (GET, POST, etc.).
        :param url: The endpoint URL.
        :param query_params: Query parameters to be appended to the URL.
        :param headers: Optional headers to include in the request.
        :param body: Optional body for the request.
        :param post_params: Optional form/multipart parameters.
        :param timeout: An optional request timeout in seconds.
        :yields: Parsed JSON objects as Python data structures.
        """

        # Initialize buffers for data chunks
        buffer = bytearray()
        leftover = b""
        response: aiohttp.ClientResponse | None = None

        try:
            # Send request, collect response handler
            async with self.pool_manager.request(
                method=request.method,
                url=request.url,
                data=request.body,
                headers=request.headers,
                params=request.fields,
                timeout=aiohttp.ClientTimeout(
                    (timeout / 1000) if timeout is not None else self._timeout
                ),
                proxy=self._configuration.proxy,
                proxy_headers=self._configuration.proxy_headers,
            ) as resp:
                response = resp
                try:
                    # Iterate over streamed/chunked response data
                    async for data, _ in resp.content.iter_chunks():
                        if data:
                            # Process data chunk
                            leftover, decoded_objects = self._accumulate_json_lines(
                                leftover, data, buffer
                            )

                            # Yield any complete objects
                            for obj in decoded_objects:
                                yield obj

                except Exception as e:
                    logger.exception("Stream reading error: %s", e)

        except Exception as conn_err:
            logger.exception("Connection or request setup error: %s", conn_err)

        # Handle any remaining data after stream ends
        if response is not None:
            # Check for any leftover data
            if leftover:
                try:
                    # Attempt to decode and yield any remaining JSON object
                    final_str = leftover.decode("utf-8")
                    final_obj = json.loads(final_str)
                    buffer.extend(leftover)
                    yield final_obj

                except json.JSONDecodeError:
                    logger.debug("Incomplete leftover data at end of stream.")

            wrapped_response = RestClientResponse(
                data=buffer,
                status=response.status,
                reason=response.reason,
                response=response,
            )

            self._log_response(wrapped_response)

            # Handle any HTTP errors that may have occurred
            await self._handle_response_exception(wrapped_response)

            # Release the response object (required!)
            response.release()

        # Release the connection back to the pool
        await self.close()

    async def request(
        self,
        request: RestClientRequestProtocol,
        timeout: int | None = None,
    ) -> RestClientResponseProtocol:
        """
        Configure and send a request.

        :param method: The HTTP method.
        :param url: The endpoint URL.
        :param query_params: Query parameters to be appended to the URL.
        :param headers: Optional request headers.
        :param body: A request body for JSON or other content types.
        :param post_params: form/multipart parameters for the request.
        :param timeout: An optional request timeout in seconds.
        """

        # Send request and collect response
        response: aiohttp.ClientResponse = await self.pool_manager.request(
            method=request.method,
            url=request.url,
            data=request.body,
            headers=request.headers,
            params=request.fields,
            timeout=aiohttp.ClientTimeout(
                (timeout / 1000) if timeout is not None else self._timeout
            ),
            proxy=self._configuration.proxy,
            proxy_headers=self._configuration.proxy_headers,
        )

        # Collect response data
        data = await response.read()

        # Transform response JSON data into RESTResponse object
        wrapped_response = RestClientResponse(
            data=data.decode("utf-8"),
            status=response.status,
            reason=response.reason,
            response=response,
        )

        self._log_response(wrapped_response)
        self._handle_response_exception(wrapped_response)

        return wrapped_response
