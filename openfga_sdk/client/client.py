"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

import asyncio
import uuid

from click import option

from openfga_sdk.client.models.assertion import ClientAssertion
from openfga_sdk.client.models.batch_check_item import (
    ClientBatchCheckItem,
    construct_batch_item,
)
from openfga_sdk.client.models.batch_check_request import ClientBatchCheckRequest
from openfga_sdk.client.models.batch_check_response import ClientBatchCheckResponse
from openfga_sdk.client.models.batch_check_single_response import (
    ClientBatchCheckSingleResponse,
)
from openfga_sdk.client.models.check_request import (
    ClientCheckRequest,
    construct_check_request,
)
from openfga_sdk.client.models.client_batch_check_response import (
    ClientBatchCheckClientResponse,
)
from openfga_sdk.client.models.expand_request import ClientExpandRequest
from openfga_sdk.client.models.list_objects_request import ClientListObjectsRequest
from openfga_sdk.client.models.list_relations_request import ClientListRelationsRequest
from openfga_sdk.client.models.list_users_request import ClientListUsersRequest
from openfga_sdk.client.models.read_changes_request import ClientReadChangesRequest
from openfga_sdk.client.models.tuple import ClientTuple, convert_tuple_keys
from openfga_sdk.client.models.write_request import ClientWriteRequest
from openfga_sdk.client.models.write_response import ClientWriteResponse
from openfga_sdk.client.models.write_single_response import ClientWriteSingleResponse
from openfga_sdk.common.client import OpenFgaClientBase
from openfga_sdk.common.headers import HttpHeaderKeys
from openfga_sdk.common.options import (
    BatchCheckRequestOptions,
    CheckRequestOptions,
    CreateStoreRequestOptions,
    DeleteStoreRequestOptions,
    ExpandRequestOptions,
    GetStoreRequestOptions,
    ListObjectsRequestOptions,
    ListRelationsRequestOptions,
    ListStoresRequestOptions,
    ListUsersRequestOptions,
    ReadAssertionsRequestOptions,
    ReadAuthorizationModelRequestOptions,
    ReadAuthorizationModelsRequestOptions,
    ReadChangesRequestOptions,
    ReadLatestAuthorizationModelRequestOptions,
    ReadRequestOptions,
    WriteAssertionsRequestOptions,
    WriteAuthorizationModelRequestOptions,
    WriteRequestOptions,
)
from openfga_sdk.exceptions import (
    AuthenticationError,
    FgaValidationException,
    UnauthorizedException,
)
from openfga_sdk.models.batch_check_request import BatchCheckRequest
from openfga_sdk.models.batch_check_response import BatchCheckResponse
from openfga_sdk.models.check_request import CheckRequest
from openfga_sdk.models.check_response import CheckResponse
from openfga_sdk.models.contextual_tuple_keys import ContextualTupleKeys
from openfga_sdk.models.create_store_request import CreateStoreRequest
from openfga_sdk.models.create_store_response import CreateStoreResponse
from openfga_sdk.models.expand_request import ExpandRequest
from openfga_sdk.models.expand_request_tuple_key import ExpandRequestTupleKey
from openfga_sdk.models.get_store_response import GetStoreResponse
from openfga_sdk.models.list_objects_request import ListObjectsRequest
from openfga_sdk.models.list_stores_response import ListStoresResponse
from openfga_sdk.models.list_users_request import ListUsersRequest
from openfga_sdk.models.read_authorization_model_response import (
    ReadAuthorizationModelResponse,
)
from openfga_sdk.models.read_authorization_models_response import (
    ReadAuthorizationModelsResponse,
)
from openfga_sdk.models.read_request import ReadRequest
from openfga_sdk.models.read_request_tuple_key import ReadRequestTupleKey
from openfga_sdk.models.streamed_list_objects_response import (
    StreamedListObjectsResponse,
)
from openfga_sdk.models.tuple_key import TupleKey
from openfga_sdk.models.write_assertions_request import WriteAssertionsRequest
from openfga_sdk.models.write_authorization_model_request import (
    WriteAuthorizationModelRequest,
)
from openfga_sdk.models.write_authorization_model_response import (
    WriteAuthorizationModelResponse,
)
from openfga_sdk.models.write_request import WriteRequest
from openfga_sdk.protocols import ApiClientResponseProtocol, FactoryProtocol


class OpenFgaClient(OpenFgaClientBase):
    async def __aenter__(self) -> "OpenFgaClient":
        return self

    async def __aexit__(self, exc_type, exc_value, traceback) -> None:
        await self.close()

    async def close(self) -> None:
        await self.api.close()

    @property
    def _factory(self) -> FactoryProtocol:
        return self._factory_async

    #################
    # Stores
    #################

    async def list_stores(
        self,
        options: ListStoresRequestOptions | None = None,
    ) -> ListStoresResponse | ApiClientResponseProtocol:
        options: ListStoresRequestOptions = ListStoresRequestOptions() | (
            options or ListStoresRequestOptions()
        )

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="ListStores",
            overwrite=False,
        )

        response = await self.api.list_stores(options)

        if options.return_response:
            return response

        return response.deserialized

    async def create_store(
        self,
        body: CreateStoreRequest,
        options: CreateStoreRequestOptions | None = None,
    ) -> CreateStoreResponse | ApiClientResponseProtocol:
        options: CreateStoreRequestOptions = CreateStoreRequestOptions() | (
            options or CreateStoreRequestOptions()
        )

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="CreateStore",
            overwrite=False,
        )

        response = await self.api.create_store(body, options)

        if options.return_response:
            return response

        return response.deserialized

    async def get_store(
        self,
        store_id: str | None = None,
        options: GetStoreRequestOptions | None = None,
    ) -> GetStoreResponse | ApiClientResponseProtocol:
        options: GetStoreRequestOptions = GetStoreRequestOptions() | (
            options or GetStoreRequestOptions()
        )

        options.store_id = store_id or options.store_id or self.configuration.store_id

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="GetStore",
            overwrite=False,
        )

        response = await self.api.get_store(options)

        if options.return_response:
            return response

        return response.deserialized

    async def delete_store(
        self,
        store_id: str | None = None,
        options: DeleteStoreRequestOptions | None = None,
    ) -> None | ApiClientResponseProtocol:
        options: DeleteStoreRequestOptions = DeleteStoreRequestOptions() | (
            options or DeleteStoreRequestOptions()
        )

        options.store_id = store_id or options.store_id or self.configuration.store_id

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="DeleteStore",
            overwrite=False,
        )

        response = await self.api.delete_store(store_id, options)

        if options.return_response:
            return response

        return None

    #######################
    # Authorization Models
    #######################

    async def read_authorization_models(
        self,
        store_id: str | None = None,
        options: ReadAuthorizationModelsRequestOptions | None = None,
    ) -> None | ApiClientResponseProtocol:
        options: ReadAuthorizationModelsRequestOptions = (
            ReadAuthorizationModelsRequestOptions()
            | (options or ReadAuthorizationModelsRequestOptions())
        )

        options.store_id = store_id or options.store_id or self.configuration.store_id

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="ReadAuthorizationModels",
            overwrite=False,
        )

        response = await self.api.read_authorization_models(options)

        if options.return_response:
            return response

        return None

    async def write_authorization_model(
        self,
        body: WriteAuthorizationModelRequest,
        options: WriteAuthorizationModelRequestOptions | None = None,
    ) -> WriteAuthorizationModelResponse | ApiClientResponseProtocol:
        options: WriteAuthorizationModelRequestOptions = (
            WriteAuthorizationModelRequestOptions()
            | (options or WriteAuthorizationModelRequestOptions())
        )

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="WriteAuthorizationModel",
            overwrite=False,
        )

        response = await self.api.write_authorization_model(body, options)

        if options.return_response:
            return response

        return response.deserialized

    async def read_authorization_model(
        self,
        authorization_model_id: str | None = None,
        options: ReadAuthorizationModelRequestOptions | None = None,
    ) -> ReadAuthorizationModelResponse | ApiClientResponseProtocol:
        options: ReadAuthorizationModelRequestOptions = (
            ReadAuthorizationModelRequestOptions()
            | (options or ReadAuthorizationModelRequestOptions())
        )

        options.authorization_model_id = (
            authorization_model_id
            or options.authorization_model_id
            or self.configuration.authorization_model_id
        )

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="ReadAuthorizationModel",
            overwrite=False,
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        response = await self.api.read_authorization_model(
            authorization_model_id, options
        )

        if options.return_response:
            return response

        return response.deserialized

    async def read_latest_authorization_model(
        self,
        options: ReadLatestAuthorizationModelRequestOptions | None = None,
    ) -> ReadAuthorizationModelResponse | ApiClientResponseProtocol:
        options: ReadAuthorizationModelsRequestOptions = (
            ReadAuthorizationModelsRequestOptions()
            | (options or ReadLatestAuthorizationModelRequestOptions())
        )
        options.page_size = 1

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="ReadLatestAuthorizationModel",
            overwrite=True,
        )

        response = self.read_authorization_models(options)

        if len(response.deserialized.authorization_models) > 0:
            response.deserialized = ReadAuthorizationModelResponse(
                response.deserialized.authorization_models[0]
            )

        if options.return_response:
            return response

        return response.deserialized

    #######################
    # Relationship Tuples
    #######################

    async def read_changes(
        self,
        body: ClientReadChangesRequest,
        options: ReadChangesRequestOptions | None = None,
    ):
        options: ReadChangesRequestOptions = ReadChangesRequestOptions() | (
            options or ReadChangesRequestOptions()
        )

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="ReadChanges",
            overwrite=False,
        )

        response = await self.api.read_changes(body, options)

        if options.return_response:
            return response

        return response.deserialized

    async def read(
        self,
        tuple_key: ReadRequestTupleKey | None = None,
        options: ReadRequestOptions | None = None,
    ):
        options: ReadRequestOptions = ReadRequestOptions() | (
            options or ReadRequestOptions()
        )

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="Read",
            overwrite=False,
        )

        request = ReadRequest(
            tuple_key=tuple_key,
            page_size=options.page_size,
            continuation_token=options.continuation_token,
            consistency=options.consistency,
        )

        response = await self.api.read(request, options)

        if options.return_response:
            return response

        return response.deserialized

    async def _write_with_transaction(
        self,
        body: ClientWriteRequest,
        options: WriteRequestOptions | None = None,
    ):
        options: WriteRequestOptions = WriteRequestOptions() | (
            options or WriteRequestOptions()
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        await self.api.write(
            WriteRequest(
                writes=body.writes_tuple_keys,
                deletes=body.deletes_tuple_keys,
                authorization_model_id=authorization_model_id,
            ),
            options,
        )

        wrote = (
            [ClientWriteSingleResponse(i, True, None) for i in body.writes]
            if body.writes
            else None
        )

        deleted = (
            [ClientWriteSingleResponse(i, True, None) for i in body.deletes]
            if body.deletes
            else None
        )

        return ClientWriteResponse(writes=wrote, deletes=deleted)

    async def _write_single_batch(
        self,
        batch: list[ClientTuple],
        is_write: bool,
        options: WriteRequestOptions | None = None,
    ):
        options: WriteRequestOptions = WriteRequestOptions() | (
            options or WriteRequestOptions()
        )

        try:
            write_batch = None
            delete_batch = None

            if is_write:
                write_batch = batch
            else:
                delete_batch = batch

            await self._write_with_transaction(
                ClientWriteRequest(writes=write_batch, deletes=delete_batch), options
            )

            return [ClientWriteSingleResponse(i, True, None) for i in batch]

        except (AuthenticationError, UnauthorizedException) as err:
            raise err

        except Exception as err:
            return [ClientWriteSingleResponse(i, False, err) for i in batch]

    async def _write_batches(
        self,
        tuple_keys: list[ClientTuple] | None,
        is_write: bool,
        options: WriteRequestOptions | None = None,
    ) -> list[ClientWriteSingleResponse] | None:
        options: WriteRequestOptions = WriteRequestOptions() | (
            options or WriteRequestOptions()
        )

        if tuple_keys is None:
            return []

        chunks = (
            tuple_keys[i : i + options.transaction.max_per_chunk]
            for i in range(0, len(tuple_keys), options.transaction.max_per_chunk)
        )

        write_batches = (
            chunks[i : i + options.transaction.max_parallel_requests]
            for i in range(
                0,
                len(chunks),
                options.transaction.max_parallel_requests,
            )
        )

        batch_write_responses = []

        for write_batch in write_batches:
            request = [
                self._write_single_batch(i, is_write, options) for i in write_batch
            ]

            response = await asyncio.gather(*request)

            flatten_list = [
                item
                for batch_single_response in response
                for item in batch_single_response
            ]

            batch_write_responses.extend(flatten_list)

        return batch_write_responses

    async def write(
        self,
        body: ClientWriteRequest,
        options: WriteRequestOptions | None = None,
    ):
        options: WriteRequestOptions = WriteRequestOptions() | (
            options or WriteRequestOptions()
        )

        options.headers.use_bulk_request_id()
        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="Write",
            overwrite=False,
        )

        if not options.transaction.disabled:
            results = await self._write_with_transaction(body, options)
            return results

        writes_response = await self._write_batches(body.writes, True, options)
        deletes_response = await self._write_batches(body.deletes, False, options)

        return ClientWriteResponse(writes=writes_response, deletes=deletes_response)

    async def write_tuples(
        self,
        body: list[ClientTuple],
        options: WriteRequestOptions | None = None,
    ):
        options: WriteRequestOptions = WriteRequestOptions() | (
            options or WriteRequestOptions()
        )

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="WriteTuples",
            overwrite=True,
        )

        return await self.write(ClientWriteRequest(writes=body), options)

    async def delete_tuples(
        self,
        body: list[ClientTuple],
        options: WriteRequestOptions | None = None,
    ):
        options: WriteRequestOptions = WriteRequestOptions() | (
            options or WriteRequestOptions()
        )

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="DeleteTuples",
            overwrite=True,
        )

        return await self.write(ClientWriteRequest(deletes=body), options)

    #######################
    # Relationship Queries
    #######################
    async def check(
        self,
        body: ClientCheckRequest,
        options: CheckRequestOptions | None = None,
    ) -> CheckResponse | ApiClientResponseProtocol:
        options: CheckRequestOptions = CheckRequestOptions() | (
            options or CheckRequestOptions()
        )

        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="Check",
            overwrite=False,
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        request = CheckRequest(
            tuple_key=TupleKey(
                user=body.user,
                relation=body.relation,
                object=body.object,
            ),
            context=body.context,
            authorization_model_id=authorization_model_id,
            consistency=options.consistency,
        )

        if body.contextual_tuples:
            request.contextual_tuples = ContextualTupleKeys(
                tuple_keys=convert_tuple_keys(body.contextual_tuples)
            )

        response = await self.api.check(request, options)

        if options.return_response:
            return response

        return response.deserialized

    async def _single_client_batch_check(
        self,
        body: ClientCheckRequest,
        semaphore: asyncio.Semaphore,
        options: BatchCheckRequestOptions | None = None,
    ) -> ClientBatchCheckClientResponse:
        options: BatchCheckRequestOptions = BatchCheckRequestOptions() | (
            options or BatchCheckRequestOptions()
        )

        await semaphore.acquire()

        try:
            response = await self.check(body, options)

            return ClientBatchCheckClientResponse(
                allowed=response.allowed,
                request=body,
                response=response,
                error=None,
            )

        except (AuthenticationError, UnauthorizedException) as err:
            raise err

        except Exception as err:
            return ClientBatchCheckClientResponse(
                allowed=False, request=body, response=None, error=err
            )

        finally:
            semaphore.release()

    async def client_batch_check(
        self,
        body: list[ClientCheckRequest],
        options: BatchCheckRequestOptions | None = None,
    ) -> list[ClientBatchCheckClientResponse]:
        options: BatchCheckRequestOptions = BatchCheckRequestOptions() | (
            options or BatchCheckRequestOptions()
        )

        options.headers.use_bulk_request_id()
        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="ClientBatchCheck",
            overwrite=True,
        )

        sem = asyncio.Semaphore(options.max_parallel_requests)

        batch_check_coros = [
            self._single_client_batch_check(request, sem, options) for request in body
        ]

        batch_check_response = await asyncio.gather(*batch_check_coros)

        return batch_check_response

    async def _single_batch_check(
        self,
        body: BatchCheckRequest,
        semaphore: asyncio.Semaphore,
        options: BatchCheckRequestOptions | None = None,
    ) -> BatchCheckResponse:
        options: BatchCheckRequestOptions = BatchCheckRequestOptions() | (
            options or BatchCheckRequestOptions()
        )

        await semaphore.acquire()

        try:
            return await self.api.batch_check(body, options)

        except Exception as err:
            raise err

        finally:
            semaphore.release()

    async def batch_check(
        self,
        body: ClientBatchCheckRequest,
        options: BatchCheckRequestOptions | None = None,
    ):
        options: BatchCheckRequestOptions = BatchCheckRequestOptions() | (
            options or BatchCheckRequestOptions()
        )

        options.headers.use_bulk_request_id()
        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="BatchCheck",
            overwrite=False,
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        id_to_check: dict[str, ClientBatchCheckItem] = {}

        def track_and_transform(checks):
            transformed = []
            for check in checks:
                if check.correlation_id is None:
                    check.correlation_id = str(uuid.uuid4())

                if check.correlation_id in id_to_check:
                    raise FgaValidationException(
                        f"Duplicate correlation_id ({check.correlation_id}) provided"
                    )

                id_to_check[check.correlation_id] = check

                transformed.append(construct_batch_item(check))
            return transformed

        checks = [
            track_and_transform(
                body.checks[
                    i * options.max_batch_size : (i + 1) * options.max_batch_size
                ]
            )
            for i in range(
                (len(body.checks) + options.max_batch_size - 1)
                // options.max_batch_size
            )
        ]

        result = []
        sem = asyncio.Semaphore(options.max_parallel_requests)

        def map_response(id, result):
            check = id_to_check[id]
            return ClientBatchCheckSingleResponse(
                allowed=result.allowed,
                request=check,
                correlation_id=id,
                error=result.error,
            )

        async def coro(checks):
            res = await self._single_batch_check(
                BatchCheckRequest(
                    checks=checks,
                    authorization_model_id=authorization_model_id,
                    consistency=options.consistency,
                ),
                sem,
                options,
            )

            result.extend(
                [map_response(c_id, c_result) for c_id, c_result in res.result.items()]
            )

        batch_check_coros = [coro(request) for request in checks]
        await asyncio.gather(*batch_check_coros)

        return ClientBatchCheckResponse(result)

    async def expand(
        self,
        body: ClientExpandRequest,
        options: ExpandRequestOptions | None = None,
    ):
        options: ExpandRequestOptions = ExpandRequestOptions() | (
            options or ExpandRequestOptions()
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        request = ExpandRequest(
            tuple_key=ExpandRequestTupleKey(
                relation=body.relation,
                object=body.object,
            ),
            authorization_model_id=authorization_model_id,
            consistency=options.consistency,
        )

        if body.contextual_tuples:
            request.contextual_tuples = ContextualTupleKeys(
                tuple_keys=convert_tuple_keys(body.contextual_tuples)
            )

        response = await self.api.expand(request, options)

        if options.return_response:
            return response

        return response.deserialized

    async def list_objects(
        self,
        body: ClientListObjectsRequest,
        options: ListObjectsRequestOptions | None = None,
    ):
        options: ListObjectsRequestOptions = ListObjectsRequestOptions() | (
            options or ListObjectsRequestOptions()
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        request = ListObjectsRequest(
            authorization_model_id=authorization_model_id,
            user=body.user,
            relation=body.relation,
            type=body.type,
            context=body.context,
            consistency=options.consistency,
        )

        if body.contextual_tuples:
            request.contextual_tuples = ContextualTupleKeys(
                tuple_keys=convert_tuple_keys(body.contextual_tuples)
            )

        response = await self.api.list_objects(request, options)

        if options.return_response:
            return response

        return response.deserialized

    async def streamed_list_objects(
        self,
        body: ClientListObjectsRequest,
        options: ListObjectsRequestOptions | None = None,
    ):
        options: ListObjectsRequestOptions = ListObjectsRequestOptions() | (
            options or ListObjectsRequestOptions()
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        request = ListObjectsRequest(
            authorization_model_id=authorization_model_id,
            user=body.user,
            relation=body.relation,
            type=body.type,
            context=body.context,
            consistency=options.consistency,
        )

        if body.contextual_tuples:
            request.contextual_tuples = ContextualTupleKeys(
                tuple_keys=convert_tuple_keys(body.contextual_tuples)
            )

        async for response in await self.api.streamed_list_objects(request, option):
            if response and "result" in response and "object" in response["result"]:
                yield StreamedListObjectsResponse(response["result"]["object"])

    async def list_relations(
        self,
        body: ClientListRelationsRequest,
        options: ListRelationsRequestOptions | None = None,
    ):
        options: ListRelationsRequestOptions = ListRelationsRequestOptions() | (
            options or ListRelationsRequestOptions()
        )

        options.headers.use_bulk_request_id()
        options.headers.add_header(
            name=HttpHeaderKeys.FGA_CLIENT_METHOD.value,
            value="ListRelations",
            overwrite=False,
        )

        request = [
            construct_check_request(
                user=body.user,
                relation=i,
                object=body.object,
                contextual_tuples=body.contextual_tuples,
                context=body.context,
            )
            for i in body.relations
        ]
        result = await self.client_batch_check(request, options)

        result_iterator = filter(lambda x: x.allowed, result)
        result_list = list(result_iterator)

        return [i.request.relation for i in result_list]

    async def list_users(
        self,
        body: ClientListUsersRequest,
        options: ListUsersRequestOptions | None = None,
    ):
        options: ListUsersRequestOptions = ListUsersRequestOptions() | (
            options or ListUsersRequestOptions()
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        request = ListUsersRequest(
            authorization_model_id=authorization_model_id,
            object=body.object,
            relation=body.relation,
            user_filters=body.user_filters,
            contextual_tuples=body.contextual_tuples,
            context=body.context,
            consistency=options.consistency,
        )

        if body.contextual_tuples:
            request.contextual_tuples = convert_tuple_keys(body.contextual_tuples)

        response = await self.api.list_users(request, options)

        if options.return_response:
            return response

        return response.deserialized

    #######################
    # Assertions
    #######################
    async def read_assertions(
        self,
        options: ReadAssertionsRequestOptions | None = None,
    ):
        options: ReadAssertionsRequestOptions = ReadAssertionsRequestOptions() | (
            options or ReadAssertionsRequestOptions()
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        response = await self.api.read_assertions(authorization_model_id, options)

        if options.return_response:
            return response

        return response.deserialized

    async def write_assertions(
        self,
        body: list[ClientAssertion],
        options: WriteAssertionsRequestOptions | None = None,
    ):
        options: WriteAssertionsRequestOptions = WriteAssertionsRequestOptions() | (
            options or WriteAssertionsRequestOptions()
        )

        authorization_model_id = (
            options.authorization_model_id or self.configuration.authorization_model_id
        )

        request = WriteAssertionsRequest(
            [assertion.to_assertion() for assertion in body]
        )

        response = await self.api.write_assertions(
            authorization_model_id, request, options
        )

        if options.return_response:
            return response

        return response.deserialized
