"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

from openfga_sdk.common.cookies import HttpCookies
from openfga_sdk.common.headers import HttpHeaders
from openfga_sdk.common.open_fga_api import ApiResponse, OpenFgaApiBase
from openfga_sdk.common.options import (
    CreateStoreRequestOptions,
    DeleteStoreRequestOptions,
    GetStoreRequestOptions,
    ListStoresRequestOptions,
    ReadAuthorizationModelRequestOptions,
    ReadAuthorizationModelsRequestOptions,
    WriteAuthorizationModelRequestOptions,
    ReadChangesRequestOptions,
    ReadRequestOptions,
    WriteRequestOptions,
)
from openfga_sdk.common.rest import (
    RestClientRequestBody,
    RestClientRequestFieldParameters,
    RestClientRequestMethod,
    RestClientRequestQueryParameters,
)
from openfga_sdk.exceptions import ApiValueError, FgaValidationException
from openfga_sdk.models.batch_check_request import BatchCheckRequest
from openfga_sdk.models.check_request import CheckRequest
from openfga_sdk.models.read_request import ReadRequest
from openfga_sdk.models.create_store_request import CreateStoreRequest
from openfga_sdk.models.write_authorization_model_request import (
    WriteAuthorizationModelRequest,
)
from openfga_sdk.models.write_request import WriteRequest
from openfga_sdk.protocols import (
    ApiClientResponseProtocol,
    ApiResponseProtocol,
    FactoryProtocol,
    StoreRequestOptionsProtocol,
    TelemetryAttributeProtocol,
)
from openfga_sdk.telemetry.attributes import TelemetryAttribute, TelemetryAttributes


class OpenFgaApi(OpenFgaApiBase):
    async def __aenter__(self) -> "OpenFgaApi":
        return self

    async def __aexit__(self, exc_type, exc_value, traceback) -> None:
        await self.close()

    async def close(self) -> None:
        self.api_client.close()

    @property
    def _factory(self) -> FactoryProtocol:
        if self.factory is None:
            return self._factory_async

        return self.factory

    async def batch_check(
        self,
        body: BatchCheckRequest | None = None,
        options: StoreRequestOptionsProtocol | None = None,
    ):
        response_types = self.build_response_types(tuple([200, "BatchCheckResponse"]))

        body: RestClientRequestBody = body or RestClientRequestBody()
        headers = HttpHeaders.for_json()
        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        cookies = HttpCookies.from_options(options)
        timeout = options.timeout
        streaming = False

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "batch_check",
            TelemetryAttributes.fga_client_request_store_id: self.configuration.store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        return await self.api_client.request(
            path=f"/stores/{store_id}/batch-check",
            method=RestClientRequestMethod("POST"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            cookies=cookies,
            timeout=timeout,
            response_types=response_types,
            attributes=attributes,
            streaming=streaming,
        )

    async def check(
        self,
        store_id: str,
        body: CheckRequest | None = None,
        options: StoreRequestOptionsProtocol | None = None,
    ):
        response_types = self.build_response_types(tuple([200, "CheckResponse"]))

        body: RestClientRequestBody = body or RestClientRequestBody()
        headers = HttpHeaders.for_json()
        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        cookies = HttpCookies.from_options(options)
        timeout = options.timeout
        streaming = False

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "check",
            TelemetryAttributes.fga_client_request_store_id: self.configuration.store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        return await self.api_client.request(
            path=f"/stores/{store_id}/check",
            method=RestClientRequestMethod("POST"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            cookies=cookies,
            timeout=timeout,
            response_types=response_types,
            attributes=attributes,
            streaming=streaming,
        )

    async def create_store(
        self,
        body: CreateStoreRequest,
        options: CreateStoreRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: CreateStoreRequestOptions = CreateStoreRequestOptions() | (
            options or CreateStoreRequestOptions()
        )
        response_types = self.build_response_types(tuple([200, "CreateStoreResponse"]))

        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "create_store",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores",
            method=RestClientRequestMethod("POST"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response

    async def delete_store(
        self,
        options: DeleteStoreRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: DeleteStoreRequestOptions = DeleteStoreRequestOptions() | (
            options or DeleteStoreRequestOptions()
        )
        response_types = self.build_response_types()

        body = None
        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "delete_store",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores/{store_id}",
            method=RestClientRequestMethod("DELETE"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response

    async def expand(self, body, **kwargs):
        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship

        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`. ### Expand Request with Contextual Tuples  Given the model ```python model     schema 1.1  type user  type folder     relations         define owner: [user]  type document     relations         define parent: [folder]         define viewer: [user] or writer         define writer: [user] or owner from parent ``` and the initial tuples ```json [{     \"user\": \"user:bob\",     \"relation\": \"owner\",     \"object\": \"folder:1\" }] ```  To expand all `writers` of `document:1` when `document:1` is put in `folder:1`, the first call could be  ```json {   \"tuple_key\": {     \"object\": \"document:1\",     \"relation\": \"writer\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"folder:1\",         \"relation\": \"parent\",         \"object\": \"document:1\"       }     ]   } } ``` this returns: ```json {   \"tree\": {     \"root\": {       \"name\": \"document:1#writer\",       \"union\": {         \"nodes\": [           {             \"name\": \"document:1#writer\",             \"leaf\": {               \"users\": {                 \"users\": []               }             }           },           {             \"name\": \"document:1#writer\",             \"leaf\": {               \"tupleToUserset\": {                 \"tupleset\": \"document:1#parent\",                 \"computed\": [                   {                     \"userset\": \"folder:1#owner\"                   }                 ]               }             }           }         ]       }     }   } } ``` This tells us that the `owner` of `folder:1` may also be a writer. So our next call could be to find the `owners` of `folder:1` ```json {   \"tuple_key\": {     \"object\": \"folder:1\",     \"relation\": \"owner\"   } } ``` which gives ```json {   \"tree\": {     \"root\": {       \"name\": \"folder:1#owner\",       \"leaf\": {         \"users\": {           \"users\": [             \"user:bob\"           ]         }       }     }   } } ```

        >>> thread = await api.expand(body)

        :param body: (required)
        :type body: ExpandRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional


        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExpandResponse
        """
        kwargs["_return_http_data_only"] = True
        return await self.expand_with_http_info(body, **kwargs)

    async def expand_with_http_info(self, body, **kwargs):
        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship

        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`. ### Expand Request with Contextual Tuples  Given the model ```python model     schema 1.1  type user  type folder     relations         define owner: [user]  type document     relations         define parent: [folder]         define viewer: [user] or writer         define writer: [user] or owner from parent ``` and the initial tuples ```json [{     \"user\": \"user:bob\",     \"relation\": \"owner\",     \"object\": \"folder:1\" }] ```  To expand all `writers` of `document:1` when `document:1` is put in `folder:1`, the first call could be  ```json {   \"tuple_key\": {     \"object\": \"document:1\",     \"relation\": \"writer\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"folder:1\",         \"relation\": \"parent\",         \"object\": \"document:1\"       }     ]   } } ``` this returns: ```json {   \"tree\": {     \"root\": {       \"name\": \"document:1#writer\",       \"union\": {         \"nodes\": [           {             \"name\": \"document:1#writer\",             \"leaf\": {               \"users\": {                 \"users\": []               }             }           },           {             \"name\": \"document:1#writer\",             \"leaf\": {               \"tupleToUserset\": {                 \"tupleset\": \"document:1#parent\",                 \"computed\": [                   {                     \"userset\": \"folder:1#owner\"                   }                 ]               }             }           }         ]       }     }   } } ``` This tells us that the `owner` of `folder:1` may also be a writer. So our next call could be to find the `owners` of `folder:1` ```json {   \"tuple_key\": {     \"object\": \"folder:1\",     \"relation\": \"owner\"   } } ``` which gives ```json {   \"tree\": {     \"root\": {       \"name\": \"folder:1#owner\",       \"leaf\": {         \"users\": {           \"users\": [             \"user:bob\"           ]         }       }     }   } } ```

        >>> thread = api.expand_with_http_info(body)

        :param body: (required)
        :type body: ExpandRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional


        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :param _retry_param: if specified, override the retry parameters specified in configuration
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExpandResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = ["body"]
        all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_request_auth",
                "_content_type",
                "_headers",
                "_retry_params",
                "_streaming",
            ]
        )

        for key, val in local_var_params["kwargs"].items():
            if key not in all_params:
                raise FgaValidationException(
                    f"Got an unexpected keyword argument '{key}' to method expand"
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'body' is set
        if (
            self.configuration.client_side_validation
            and local_var_params.get("body") is None
        ):
            raise ApiValueError(
                "Missing the required parameter `body` when calling `expand`"
            )

        collection_formats = {}

        path_params = {}

        store_id = None

        if self.api_client._get_store_id() is None:
            raise ApiValueError(
                "Store ID expected in api_client's configuration when calling `expand`"
            )
        store_id = self.api_client._get_store_id()

        query_params = []

        header_params = dict(local_var_params.get("_headers", {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in local_var_params:
            body_params = local_var_params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get(
            "_content_type",
            self.api_client.select_header_content_type(
                ["application/json"], "POST", body_params
            ),
        )
        if content_types_list:
            header_params["Content-Type"] = content_types_list

        # Authentication setting
        auth_settings = []

        response_types_map = {
            200: "ExpandResponse",
            400: "ValidationErrorMessageResponse",
            401: "UnauthenticatedResponse",
            403: "ForbiddenResponse",
            404: "PathUnknownErrorMessageResponse",
            409: "AbortedMessageResponse",
            422: "UnprocessableContentMessageResponse",
            500: "InternalErrorMessageResponse",
        }

        telemetry_attributes: dict[TelemetryAttribute, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "expand",
            TelemetryAttributes.fga_client_request_store_id: self.api_client.get_store_id(),
            TelemetryAttributes.fga_client_request_model_id: local_var_params.get(
                "authorization_model_id", ""
            ),
        }

        telemetry_attributes = TelemetryAttributes.fromBody(
            body=body_params,
            attributes=telemetry_attributes,
        )

        return await self.api_client.call_api(
            "/stores/{store_id}/expand".replace("{store_id}", store_id),
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get("_return_http_data_only"),
            _retry_params=local_var_params.get("_retry_params"),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get("_request_auth"),
            _oauth2_client=self.auth_client,
            _telemetry_attributes=telemetry_attributes,
            _streaming=local_var_params.get("_streaming", False),
        )

    async def get_store(
        self,
        options: GetStoreRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: GetStoreRequestOptions = GetStoreRequestOptions() | (
            options or GetStoreRequestOptions()
        )
        response_types = self.build_response_types(tuple([200, "GetStoreResponse"]))

        body = None
        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "get_store",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores/{store_id}",
            method=RestClientRequestMethod("GET"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response

    async def list_objects(self, body, **kwargs):
        """List all objects of the given type that the user has a relation with

        The ListObjects API returns a list of all the objects of the given type that the user has a relation with.  To arrive at a result, the API uses: an authorization model, explicit tuples written through the Write API, contextual tuples present in the request, and implicit tuples that exist by virtue of applying set theory (such as `document:2021-budget#viewer@document:2021-budget#viewer`; the set of users who are viewers of `document:2021-budget` are the set of users who are the viewers of `document:2021-budget`). An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. By default, the Check API caches results for a short time to optimize performance. You may specify a value of `HIGHER_CONSISTENCY` for the optional `consistency` parameter in the body to inform the server that higher conisistency is preferred at the expense of increased latency. Consideration should be given to the increased latency if requesting higher consistency. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.

        >>> thread = await api.list_objects(body)

        :param body: (required)
        :type body: ListObjectsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional


        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListObjectsResponse
        """
        kwargs["_return_http_data_only"] = True
        return await self.list_objects_with_http_info(body, **kwargs)

    async def list_objects_with_http_info(self, body, **kwargs):
        """List all objects of the given type that the user has a relation with

        The ListObjects API returns a list of all the objects of the given type that the user has a relation with.  To arrive at a result, the API uses: an authorization model, explicit tuples written through the Write API, contextual tuples present in the request, and implicit tuples that exist by virtue of applying set theory (such as `document:2021-budget#viewer@document:2021-budget#viewer`; the set of users who are viewers of `document:2021-budget` are the set of users who are the viewers of `document:2021-budget`). An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. By default, the Check API caches results for a short time to optimize performance. You may specify a value of `HIGHER_CONSISTENCY` for the optional `consistency` parameter in the body to inform the server that higher conisistency is preferred at the expense of increased latency. Consideration should be given to the increased latency if requesting higher consistency. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.

        >>> thread = api.list_objects_with_http_info(body)

        :param body: (required)
        :type body: ListObjectsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional


        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :param _retry_param: if specified, override the retry parameters specified in configuration
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListObjectsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = ["body"]
        all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_request_auth",
                "_content_type",
                "_headers",
                "_retry_params",
                "_streaming",
            ]
        )

        for key, val in local_var_params["kwargs"].items():
            if key not in all_params:
                raise FgaValidationException(
                    f"Got an unexpected keyword argument '{key}' to method list_objects"
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'body' is set
        if (
            self.configuration.client_side_validation
            and local_var_params.get("body") is None
        ):
            raise ApiValueError(
                "Missing the required parameter `body` when calling `list_objects`"
            )

        collection_formats = {}

        path_params = {}

        store_id = None

        if self.api_client._get_store_id() is None:
            raise ApiValueError(
                "Store ID expected in api_client's configuration when calling `list_objects`"
            )
        store_id = self.api_client._get_store_id()

        query_params = []

        header_params = dict(local_var_params.get("_headers", {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in local_var_params:
            body_params = local_var_params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get(
            "_content_type",
            self.api_client.select_header_content_type(
                ["application/json"], "POST", body_params
            ),
        )
        if content_types_list:
            header_params["Content-Type"] = content_types_list

        # Authentication setting
        auth_settings = []

        response_types_map = {
            200: "ListObjectsResponse",
            400: "ValidationErrorMessageResponse",
            401: "UnauthenticatedResponse",
            403: "ForbiddenResponse",
            404: "PathUnknownErrorMessageResponse",
            409: "AbortedMessageResponse",
            422: "UnprocessableContentMessageResponse",
            500: "InternalErrorMessageResponse",
        }

        telemetry_attributes: dict[TelemetryAttribute, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "list_objects",
            TelemetryAttributes.fga_client_request_store_id: self.api_client.get_store_id(),
            TelemetryAttributes.fga_client_request_model_id: local_var_params.get(
                "authorization_model_id", ""
            ),
        }

        telemetry_attributes = TelemetryAttributes.fromBody(
            body=body_params,
            attributes=telemetry_attributes,
        )

        return await self.api_client.call_api(
            "/stores/{store_id}/list-objects".replace("{store_id}", store_id),
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get("_return_http_data_only"),
            _retry_params=local_var_params.get("_retry_params"),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get("_request_auth"),
            _oauth2_client=self.auth_client,
            _telemetry_attributes=telemetry_attributes,
            _streaming=local_var_params.get("_streaming", False),
        )

    async def list_stores(
        self,
        options: ListStoresRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: ListStoresRequestOptions = ListStoresRequestOptions() | (
            options or ListStoresRequestOptions()
        )
        response_types = self.build_response_types(tuple([200, "ListStoresResponse"]))

        body = None
        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "list_stores",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores",
            method=RestClientRequestMethod("GET"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response

    async def list_users(self, body, **kwargs):
        """List the users matching the provided filter who have a certain relation to a particular type.

        The ListUsers API returns a list of all the users of a specific type that have a relation to a given object.  To arrive at a result, the API uses: an authorization model, explicit tuples written through the Write API, contextual tuples present in the request, and implicit tuples that exist by virtue of applying set theory (such as `document:2021-budget#viewer@document:2021-budget#viewer`; the set of users who are viewers of `document:2021-budget` are the set of users who are the viewers of `document:2021-budget`). An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related users in an array in the \"users\" field of the response. These results may include specific objects, usersets  or type-bound public access. Each of these types of results is encoded in its own type and not represented as a string.In cases where a type-bound public access result is returned (e.g. `user:*`), it cannot be inferred that all subjects of that type have a relation to the object; it is possible that negations exist and checks should still be queried on individual subjects to ensure access to that document.The number of users in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_USERS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_USERS_MAX_RESULTS, whichever is hit first. The returned users will not be sorted, and therefore two identical calls may yield different sets of users.

        >>> thread = await api.list_users(body)

        :param body: (required)
        :type body: ListUsersRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional


        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListUsersResponse
        """
        kwargs["_return_http_data_only"] = True
        return await self.list_users_with_http_info(body, **kwargs)

    async def list_users_with_http_info(self, body, **kwargs):
        """List the users matching the provided filter who have a certain relation to a particular type.

        The ListUsers API returns a list of all the users of a specific type that have a relation to a given object.  To arrive at a result, the API uses: an authorization model, explicit tuples written through the Write API, contextual tuples present in the request, and implicit tuples that exist by virtue of applying set theory (such as `document:2021-budget#viewer@document:2021-budget#viewer`; the set of users who are viewers of `document:2021-budget` are the set of users who are the viewers of `document:2021-budget`). An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related users in an array in the \"users\" field of the response. These results may include specific objects, usersets  or type-bound public access. Each of these types of results is encoded in its own type and not represented as a string.In cases where a type-bound public access result is returned (e.g. `user:*`), it cannot be inferred that all subjects of that type have a relation to the object; it is possible that negations exist and checks should still be queried on individual subjects to ensure access to that document.The number of users in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_USERS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_USERS_MAX_RESULTS, whichever is hit first. The returned users will not be sorted, and therefore two identical calls may yield different sets of users.

        >>> thread = api.list_users_with_http_info(body)

        :param body: (required)
        :type body: ListUsersRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional


        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :param _retry_param: if specified, override the retry parameters specified in configuration
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListUsersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = ["body"]
        all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_request_auth",
                "_content_type",
                "_headers",
                "_retry_params",
                "_streaming",
            ]
        )

        for key, val in local_var_params["kwargs"].items():
            if key not in all_params:
                raise FgaValidationException(
                    f"Got an unexpected keyword argument '{key}' to method list_users"
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'body' is set
        if (
            self.configuration.client_side_validation
            and local_var_params.get("body") is None
        ):
            raise ApiValueError(
                "Missing the required parameter `body` when calling `list_users`"
            )

        collection_formats = {}

        path_params = {}

        store_id = None

        if self.api_client._get_store_id() is None:
            raise ApiValueError(
                "Store ID expected in api_client's configuration when calling `list_users`"
            )
        store_id = self.api_client._get_store_id()

        query_params = []

        header_params = dict(local_var_params.get("_headers", {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in local_var_params:
            body_params = local_var_params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get(
            "_content_type",
            self.api_client.select_header_content_type(
                ["application/json"], "POST", body_params
            ),
        )
        if content_types_list:
            header_params["Content-Type"] = content_types_list

        # Authentication setting
        auth_settings = []

        response_types_map = {
            200: "ListUsersResponse",
            400: "ValidationErrorMessageResponse",
            401: "UnauthenticatedResponse",
            403: "ForbiddenResponse",
            404: "PathUnknownErrorMessageResponse",
            409: "AbortedMessageResponse",
            422: "UnprocessableContentMessageResponse",
            500: "InternalErrorMessageResponse",
        }

        telemetry_attributes: dict[TelemetryAttribute, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "list_users",
            TelemetryAttributes.fga_client_request_store_id: self.api_client.get_store_id(),
            TelemetryAttributes.fga_client_request_model_id: local_var_params.get(
                "authorization_model_id", ""
            ),
        }

        telemetry_attributes = TelemetryAttributes.fromBody(
            body=body_params,
            attributes=telemetry_attributes,
        )

        return await self.api_client.call_api(
            "/stores/{store_id}/list-users".replace("{store_id}", store_id),
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get("_return_http_data_only"),
            _retry_params=local_var_params.get("_retry_params"),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get("_request_auth"),
            _oauth2_client=self.auth_client,
            _telemetry_attributes=telemetry_attributes,
            _streaming=local_var_params.get("_streaming", False),
        )

    async def read(
        self,
        body: ReadRequest,
        options: ReadRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: ReadRequestOptions = ReadRequestOptions() | (
            options or ReadRequestOptions()
        )
        response_types = self.build_response_types(tuple([200, "ReadResponse"]))

        body = None
        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "read",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores/{store_id}/read",
            method=RestClientRequestMethod("GET"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response

    async def read_assertions(self, authorization_model_id, **kwargs):
        """Read assertions for an authorization model ID

        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it.

        >>> thread = await api.read_assertions(authorization_model_id)

        :param authorization_model_id: (required)
        :type authorization_model_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional


        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReadAssertionsResponse
        """
        kwargs["_return_http_data_only"] = True
        return await self.read_assertions_with_http_info(
            authorization_model_id, **kwargs
        )

    async def read_assertions_with_http_info(self, authorization_model_id, **kwargs):
        """Read assertions for an authorization model ID

        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it.

        >>> thread = api.read_assertions_with_http_info(authorization_model_id)

        :param authorization_model_id: (required)
        :type authorization_model_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional


        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :param _retry_param: if specified, override the retry parameters specified in configuration
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReadAssertionsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = ["authorization_model_id"]
        all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_request_auth",
                "_content_type",
                "_headers",
                "_retry_params",
                "_streaming",
            ]
        )

        for key, val in local_var_params["kwargs"].items():
            if key not in all_params:
                raise FgaValidationException(
                    f"Got an unexpected keyword argument '{key}' to method read_assertions"
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'authorization_model_id' is set
        if (
            self.configuration.client_side_validation
            and local_var_params.get("authorization_model_id") is None
        ):
            raise ApiValueError(
                "Missing the required parameter `authorization_model_id` when calling `read_assertions`"
            )

        collection_formats = {}

        path_params = {}

        store_id = None

        if self.api_client._get_store_id() is None:
            raise ApiValueError(
                "Store ID expected in api_client's configuration when calling `read_assertions`"
            )
        store_id = self.api_client._get_store_id()

        if "authorization_model_id" in local_var_params:
            path_params["authorization_model_id"] = local_var_params[
                "authorization_model_id"
            ]

        query_params = []

        header_params = dict(local_var_params.get("_headers", {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # Authentication setting
        auth_settings = []

        response_types_map = {
            200: "ReadAssertionsResponse",
            400: "ValidationErrorMessageResponse",
            401: "UnauthenticatedResponse",
            403: "ForbiddenResponse",
            404: "PathUnknownErrorMessageResponse",
            409: "AbortedMessageResponse",
            422: "UnprocessableContentMessageResponse",
            500: "InternalErrorMessageResponse",
        }

        telemetry_attributes: dict[TelemetryAttribute, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "read_assertions",
            TelemetryAttributes.fga_client_request_store_id: self.api_client.get_store_id(),
            TelemetryAttributes.fga_client_request_model_id: local_var_params.get(
                "authorization_model_id", ""
            ),
        }

        telemetry_attributes = TelemetryAttributes.fromBody(
            body=body_params,
            attributes=telemetry_attributes,
        )

        return await self.api_client.call_api(
            "/stores/{store_id}/assertions/{authorization_model_id}".replace(
                "{store_id}", store_id
            ),
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get("_return_http_data_only"),
            _retry_params=local_var_params.get("_retry_params"),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get("_request_auth"),
            _oauth2_client=self.auth_client,
            _telemetry_attributes=telemetry_attributes,
            _streaming=local_var_params.get("_streaming", False),
        )

    async def read_authorization_model(
        self,
        authorization_model_id: str,
        options: ReadAuthorizationModelRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: ReadAuthorizationModelRequestOptions = (
            ReadAuthorizationModelRequestOptions()
            | (options or ReadAuthorizationModelRequestOptions())
        )
        response_types = self.build_response_types(
            tuple([200, "ReadAuthorizationModelResponse"])
        )

        body = None
        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "read_authorization_model",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores/{store_id}/authorization-models/{authorization_model_id}",
            method=RestClientRequestMethod("GET"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response

    async def read_authorization_models(
        self,
        options: ReadAuthorizationModelsRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: ReadAuthorizationModelsRequestOptions = (
            ReadAuthorizationModelsRequestOptions()
            | (options or ReadAuthorizationModelsRequestOptions())
        )
        response_types = self.build_response_types(
            tuple([200, "ReadAuthorizationModelsResponse"])
        )

        body = None
        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "read_authorization_models",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores/{store_id}/authorization-models",
            method=RestClientRequestMethod("GET"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response

    async def read_changes(
        self,
        options: ReadChangesRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: ReadChangesRequestOptions = ReadChangesRequestOptions() | (
            options or ReadChangesRequestOptions()
        )
        response_types = self.build_response_types(tuple([200, "ReadChangesResponse"]))

        body = None
        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "read_changes",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores/{store_id}/changes",
            method=RestClientRequestMethod("GET"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response

    async def streamed_list_objects(self, body, **kwargs):
        """Stream all objects of the given type that the user has a relation with

        The Streamed ListObjects API is very similar to the the ListObjects API, with two differences:  1. Instead of collecting all objects before returning a response, it streams them to the client as they are collected.  2. The number of results returned is only limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE.

        >>> thread = await api.streamed_list_objects(body)

        :param body: (required)
        :type body: ListObjectsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional


        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamResultOfStreamedListObjectsResponse
        """
        kwargs["_return_http_data_only"] = True
        return await self.streamed_list_objects_with_http_info(body, **kwargs)

    async def streamed_list_objects_with_http_info(self, body, **kwargs):
        """Stream all objects of the given type that the user has a relation with

        The Streamed ListObjects API is very similar to the the ListObjects API, with two differences:  1. Instead of collecting all objects before returning a response, it streams them to the client as they are collected.  2. The number of results returned is only limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE.

        >>> thread = api.streamed_list_objects_with_http_info(body)

        :param body: (required)
        :type body: ListObjectsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional


        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :param _retry_param: if specified, override the retry parameters specified in configuration
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamResultOfStreamedListObjectsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = ["body"]
        all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_request_auth",
                "_content_type",
                "_headers",
                "_retry_params",
                "_streaming",
            ]
        )

        for key, val in local_var_params["kwargs"].items():
            if key not in all_params:
                raise FgaValidationException(
                    f"Got an unexpected keyword argument '{key}' to method streamed_list_objects"
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'body' is set
        if (
            self.configuration.client_side_validation
            and local_var_params.get("body") is None
        ):
            raise ApiValueError(
                "Missing the required parameter `body` when calling `streamed_list_objects`"
            )

        collection_formats = {}

        path_params = {}

        store_id = None

        if self.api_client._get_store_id() is None:
            raise ApiValueError(
                "Store ID expected in api_client's configuration when calling `streamed_list_objects`"
            )
        store_id = self.api_client._get_store_id()

        query_params = []

        header_params = dict(local_var_params.get("_headers", {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in local_var_params:
            body_params = local_var_params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get(
            "_content_type",
            self.api_client.select_header_content_type(
                ["application/json"], "POST", body_params
            ),
        )
        if content_types_list:
            header_params["Content-Type"] = content_types_list

        # Authentication setting
        auth_settings = []

        response_types_map = {
            200: "StreamResultOfStreamedListObjectsResponse",
            400: "ValidationErrorMessageResponse",
            401: "UnauthenticatedResponse",
            403: "ForbiddenResponse",
            404: "PathUnknownErrorMessageResponse",
            409: "AbortedMessageResponse",
            422: "UnprocessableContentMessageResponse",
            500: "InternalErrorMessageResponse",
        }

        telemetry_attributes: dict[TelemetryAttribute, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "streamed_list_objects",
            TelemetryAttributes.fga_client_request_store_id: self.api_client.get_store_id(),
            TelemetryAttributes.fga_client_request_model_id: local_var_params.get(
                "authorization_model_id", ""
            ),
        }

        telemetry_attributes = TelemetryAttributes.fromBody(
            body=body_params,
            attributes=telemetry_attributes,
        )

        return await self.api_client.call_api(
            "/stores/{store_id}/streamed-list-objects".replace("{store_id}", store_id),
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get("_return_http_data_only"),
            _retry_params=local_var_params.get("_retry_params"),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get("_request_auth"),
            _oauth2_client=self.auth_client,
            _telemetry_attributes=telemetry_attributes,
            _streaming=local_var_params.get("_streaming", False),
        )

    async def write(
        self,
        body: WriteRequest,
        options: WriteRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: WriteRequestOptions = WriteRequestOptions() | (
            options or WriteRequestOptions()
        )
        response_types = self.build_response_types(tuple([200, "object"]))

        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "write",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores/{store_id}/write",
            method=RestClientRequestMethod("GET"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response

    async def write_assertions(self, authorization_model_id, body, **kwargs):
        """Upsert assertions for an authorization model ID

        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, the expectation of whether a call to the Check API of that tuple key will return true or false, and optionally a list of contextual tuples.

        >>> thread = await api.write_assertions(authorization_model_id, body)

        :param authorization_model_id: (required)
        :type authorization_model_id: str
        :param body: (required)
        :type body: WriteAssertionsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional


        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return await self.write_assertions_with_http_info(
            authorization_model_id, body, **kwargs
        )

    async def write_assertions_with_http_info(
        self, authorization_model_id, body, **kwargs
    ):
        """Upsert assertions for an authorization model ID

        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, the expectation of whether a call to the Check API of that tuple key will return true or false, and optionally a list of contextual tuples.

        >>> thread = api.write_assertions_with_http_info(authorization_model_id, body)

        :param authorization_model_id: (required)
        :type authorization_model_id: str
        :param body: (required)
        :type body: WriteAssertionsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional


        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :param _retry_param: if specified, override the retry parameters specified in configuration
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = ["authorization_model_id", "body"]
        all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_request_auth",
                "_content_type",
                "_headers",
                "_retry_params",
                "_streaming",
            ]
        )

        for key, val in local_var_params["kwargs"].items():
            if key not in all_params:
                raise FgaValidationException(
                    f"Got an unexpected keyword argument '{key}' to method write_assertions"
                )
            local_var_params[key] = val
        del local_var_params["kwargs"]
        # verify the required parameter 'authorization_model_id' is set
        if (
            self.configuration.client_side_validation
            and local_var_params.get("authorization_model_id") is None
        ):
            raise ApiValueError(
                "Missing the required parameter `authorization_model_id` when calling `write_assertions`"
            )
        # verify the required parameter 'body' is set
        if (
            self.configuration.client_side_validation
            and local_var_params.get("body") is None
        ):
            raise ApiValueError(
                "Missing the required parameter `body` when calling `write_assertions`"
            )

        collection_formats = {}

        path_params = {}

        store_id = None

        if self.api_client._get_store_id() is None:
            raise ApiValueError(
                "Store ID expected in api_client's configuration when calling `write_assertions`"
            )
        store_id = self.api_client._get_store_id()

        if "authorization_model_id" in local_var_params:
            path_params["authorization_model_id"] = local_var_params[
                "authorization_model_id"
            ]

        query_params = []

        header_params = dict(local_var_params.get("_headers", {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in local_var_params:
            body_params = local_var_params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get(
            "_content_type",
            self.api_client.select_header_content_type(
                ["application/json"], "PUT", body_params
            ),
        )
        if content_types_list:
            header_params["Content-Type"] = content_types_list

        # Authentication setting
        auth_settings = []

        response_types_map = {}

        telemetry_attributes: dict[TelemetryAttribute, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "write_assertions",
            TelemetryAttributes.fga_client_request_store_id: self.api_client.get_store_id(),
            TelemetryAttributes.fga_client_request_model_id: local_var_params.get(
                "authorization_model_id", ""
            ),
        }

        telemetry_attributes = TelemetryAttributes.fromBody(
            body=body_params,
            attributes=telemetry_attributes,
        )

        return await self.api_client.call_api(
            "/stores/{store_id}/assertions/{authorization_model_id}".replace(
                "{store_id}", store_id
            ),
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get("async_req"),
            _return_http_data_only=local_var_params.get("_return_http_data_only"),
            _retry_params=local_var_params.get("_retry_params"),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get("_request_auth"),
            _oauth2_client=self.auth_client,
            _telemetry_attributes=telemetry_attributes,
            _streaming=local_var_params.get("_streaming", False),
        )

    async def write_authorization_model(
        self,
        body: WriteAuthorizationModelRequest,
        options: WriteAuthorizationModelRequestOptions | None = None,
    ) -> ApiResponseProtocol:
        options: WriteAuthorizationModelRequestOptions = (
            WriteAuthorizationModelRequestOptions()
            | (options or WriteAuthorizationModelRequestOptions())
        )

        response_types = self.build_response_types(
            tuple([200, "WriteAuthorizationModelResponse"])
        )

        query = RestClientRequestQueryParameters.from_options(options)
        fields = RestClientRequestFieldParameters()
        streaming = False
        store_id = options.store_id or self.configuration.store_id

        headers = HttpHeaders()
        headers.add_header("Accept", "application/json")
        headers.add_header("Content-Type", "application/json")

        attributes: dict[TelemetryAttributeProtocol, str | bool | int | float] = {
            TelemetryAttributes.fga_client_request_method: "write_authorization_model",
            TelemetryAttributes.fga_client_request_store_id: store_id,
            TelemetryAttributes.fga_client_request_model_id: self.configuration.authorization_model_id,
        }

        attributes = TelemetryAttributes.fromBody(
            body=body,
            attributes=attributes,
        )

        api_client_response: ApiClientResponseProtocol = await self.api_client.request(
            path=f"/stores/{store_id}/authorization-models",
            method=RestClientRequestMethod("POST"),
            body=body,
            headers=headers,
            query=query,
            fields=fields,
            attributes=attributes,
            streaming=streaming,
        )

        api_response: ApiResponseProtocol = ApiResponse() | api_client_response

        api_response.deserialized = self.deserialize(
            api_response.response, response_types
        )

        return api_response
