"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

from dataclasses import dataclass, field, fields
from enum import Enum
import uuid

from openfga_sdk.protocols import (
    HttpHeaderProtocol,
    HttpHeadersProtocol,
    MergeableDataclassMixin,
    StoreRequestOptionsProtocol,
)


class HttpHeaderKeys(Enum):
    CONTENT_TYPE = "Content-Type"
    FGA_CLIENT_METHOD = "X-OpenFGA-Client-Method"
    FGA_CLIENT_BULK_REQUEST_ID_HEADER = "X-OpenFGA-Client-Bulk-Request-Id"


@dataclass
class HttpHeader(HttpHeaderProtocol):
    name: str
    value: str


@dataclass
class HttpHeaders(MergeableDataclassMixin, HttpHeadersProtocol):
    headers: dict[str, HttpHeaderProtocol] = field(default_factory=dict)

    def add_header(self, name: str, value: str, overwrite: bool | None = None) -> None:
        key = name.lower()

        if overwrite == False and key in self.headers:
            return

        header = HttpHeader(name=name, value=value)

        if overwrite == True:
            self.headers[key] = [header]

        self.headers.setdefault(key, []).append(header)

    def insert_header(self, header: HttpHeaderProtocol) -> None:
        key = header.name.lower()
        self.headers.setdefault(key, []).append(header)

    def use_bulk_request_id(self, value: str | None = None) -> None:
        self.add_header(
            HttpHeaderKeys.FGA_CLIENT_BULK_REQUEST_ID_HEADER.value,
            value or str(uuid.uuid4()),
        )

    def get_header(self, name: str) -> list:
        return [header for header in self.headers.get(name.lower(), [])]

    def remove_header(self, name: str) -> None:
        self.headers.pop(name.lower(), None)

    def merge(self, other: "HttpHeadersProtocol") -> None:
        for name, headers_list in other.headers.items():
            if name in self.headers:
                self.headers[name].extend(headers_list)
            else:
                self.headers[name] = headers_list.copy()

    def as_dict(self) -> dict[str, str]:
        return {name: value for name, value in self.headers.items()}

    def __getitem__(self, name: str) -> list:
        return self.get_header(name)

    def __setitem__(self, name: str, value: str) -> None:
        self.headers[name.lower()] = [HttpHeader(name=name, value=value)]

    def __delitem__(self, name: str) -> None:
        self.remove_header(name)

    def __contains__(self, name: str) -> bool:
        return name.lower() in self.headers

    def __iter__(self):
        return iter(self.headers)

    def items(self):
        for key, headers in self.headers.items():
            for header in headers:
                yield (header.name, header.value)

    def __str__(self) -> str:
        return "\n".join(
            str(header) for headers in self.headers.values() for header in headers
        )

    @staticmethod
    def for_json() -> "HttpHeadersProtocol":
        headers = HttpHeaders()
        headers.add_header("Content-Type", "application/json")
        headers.add_header("Accept", "application/json")
        return headers

    @staticmethod
    def from_options(
        options: StoreRequestOptionsProtocol | None,
    ) -> "HttpHeadersProtocol":
        headers = HttpHeaders()

        if options is None:
            return headers

        for field in fields(options):
            value = getattr(options, field.name)

            if value is None:
                continue

            match field.name:
                case "headers":
                    if isinstance(value, HttpHeadersProtocol):
                        headers.merge(value)

        return headers
