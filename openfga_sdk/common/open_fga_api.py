"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

import datetime
import functools
import logging
import re

from dataclasses import dataclass
from typing import Any

import orjson

from dateutil.parser import parse  # type: ignore[import-untyped]

import openfga_sdk.models

from openfga_sdk.common.factory import FactoryConsumer
from openfga_sdk.exceptions import ApiException
from openfga_sdk.protocols import (
    ApiResponseProtocol,
    ConfigurationProtocol,
    FactoryProtocol,
    FgaModelProtocol,
    MergeableDataclassMixin,
    OpenFgaApiProtocol,
    RestClientRequestProtocol,
    RestClientResponseProtocol,
)


logger = logging.getLogger(__name__)


@dataclass
class ApiResponse(MergeableDataclassMixin, ApiResponseProtocol):
    retries: int = 0
    exception: Exception | None = None
    request: RestClientRequestProtocol | None = None
    response: RestClientResponseProtocol | None = None
    deserialized: FgaModelProtocol | None = None

    @property
    def status(self) -> int | None:
        if self.response:
            return self.response.status


@dataclass
class OpenFgaApiBase(FactoryConsumer, OpenFgaApiProtocol):
    configuration: ConfigurationProtocol
    factory: FactoryProtocol | None = None

    TYPE_PATTERN = re.compile(r"(?P<container>list|dict)\[(?P<content>.+)\]")

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)

    NATIVE_TYPES_MAPPING = {
        "int": int,
        "long": int,
        "float": float,
        "str": str,
        "bool": bool,
        "date": datetime.date,
        "datetime": datetime.datetime,
        "object": object,
    }

    @staticmethod
    @functools.lru_cache()
    def build_response_types(
        extra_response_type: tuple[int, str] | None = None,
    ) -> tuple[tuple[int, str], ...]:
        """
        Build the list of response types, including optional extra response types.

        Args:
            extra_response_type (tuple[int, str] | None): An optional additional response type.

        Returns:
            tuple[tuple[int, str], ...]: A tuple of response type mappings.
        """

        response_types = (
            (400, "ValidationErrorMessageResponse"),
            (401, "UnauthenticatedResponse"),
            (403, "ForbiddenResponse"),
            (404, "PathUnknownErrorMessageResponse"),
            (409, "AbortedMessageResponse"),
            (422, "UnprocessableContentMessageResponse"),
            (500, "InternalErrorMessageResponse"),
        )

        if extra_response_type:
            return response_types + (extra_response_type,)

        return response_types

    def deserialize(
        self,
        response: RestClientResponseProtocol,
        response_types: list[tuple[int, str]],
    ):
        """
        Deserialize a response to the appropriate model based on the status code.

        Args:
            response (RestClientResponseProtocol): The HTTP response to deserialize.
            response_types (list[tuple[int, str]]): Tuples of status code and response class.

        Returns:
            Any: The deserialized object or raw data if no matching response type is found.

        Raises:
            ValueError: If no matching response type is found and raw data is not allowed.
        """

        # response.data is a JSON string; convert to dict
        data = None if not response.data else orjson.loads(response.data)

        for status, response_type in response_types:
            if response.status == status:
                return self._deserialize(data, response_type)

        return data

    def _deserialize(
        self,
        data: Any,
        response_type: str | type,
    ) -> Any:
        if data is None:
            return None

        logger.debug(f"_deserialize: data: {data}, response_type: {response_type}")

        if isinstance(response_type, type):
            if response_type in self.PRIMITIVE_TYPES:
                return OpenFgaApiBase._deserialize_primitive(data, response_type)

            if response_type is object:
                return data

            if response_type is datetime.date:
                return OpenFgaApiBase._deserialize_date(data)

            if response_type is datetime.datetime:
                return OpenFgaApiBase._deserialize_datetime(data)

            return self._deserialize_model(data, response_type)

        if isinstance(response_type, str):
            parsed_type = self._process_nested_types(response_type)
            logger.debug(f"Parsed type: {parsed_type}")

            if isinstance(parsed_type, list):
                sub_class = parsed_type[0]
                return [self._deserialize(sub_data, sub_class) for sub_data in data]

            if isinstance(parsed_type, dict):
                key_kls = parsed_type["key"]
                value_kls = parsed_type["value"]
                return {
                    self._deserialize(k, key_kls): self._deserialize(v, value_kls)
                    for k, v in data.items()
                }

            if parsed_type in self.NATIVE_TYPES_MAPPING:
                response_type = self.NATIVE_TYPES_MAPPING[parsed_type]
            else:
                try:
                    response_type = getattr(openfga_sdk.models, parsed_type)
                except AttributeError:
                    raise ValueError(f"Unknown response type: {parsed_type}")

        return self._deserialize(data, response_type)

    def _deserialize_model(
        self,
        data: dict | list,
        response_class: str | type,
    ) -> Any:
        if not isinstance(response_class, str | type):
            raise TypeError(
                f"Expected a string or class for response_class, got {type(response_class).__name__}: {response_class}"
            )

        if isinstance(response_class, str):
            response_class = OpenFgaApiBase._get_openapi_model(response_class)

        if not response_class:
            raise ValueError(
                f"Model {response_class} not found in `openfga_sdk.models`"
            )

        if not getattr(response_class, "openapi_types", None):
            allowable_values: list | None = getattr(
                response_class, "allowable_values", None
            )

            if isinstance(allowable_values, list) and data in allowable_values:
                logger.debug(
                    f"_deserialize: data: {data}, response_type: {response_class}, HIT HIT HIT"
                )
                return data

            return response_class(data)

        attributes = {}

        for attr, attr_type in response_class.openapi_types.items():
            json_key = response_class.attribute_map.get(attr, attr)

            if json_key in data and data[json_key] is not None:
                value = data[json_key]
                attributes[attr] = self._deserialize(value, attr_type)

        return response_class(**attributes)

    @staticmethod
    @functools.lru_cache()
    def _get_openapi_model(model_name: str) -> type | None:
        if not isinstance(model_name, str):
            raise TypeError(
                f"Expected a string for model_name, got {type(model_name).__name__}: {model_name}"
            )

        model_class = getattr(openfga_sdk.models, model_name, None)

        if not model_class:
            logger.warning(f"Model {model_name} not found in `openfga_sdk.models`")

        return model_class

    @staticmethod
    @functools.lru_cache()
    def _process_nested_types(type_str: str) -> list | dict | str:
        """
        Process nested type strings like `list[Store]` or `dict[str, Store]`.
        """
        match = OpenFgaApiBase.TYPE_PATTERN.match(type_str)

        if not match:
            return type_str

        container = match.group("container")
        content = match.group("content")

        try:
            if container == "list":
                return [OpenFgaApiBase._process_nested_types(content.strip())]

            if container == "dict":
                key_type, value_type = map(str.strip, content.split(",", 1))
                return {
                    "key": OpenFgaApiBase._process_nested_types(key_type),
                    "value": OpenFgaApiBase._process_nested_types(value_type),
                }

            if container == "tuple":
                return tuple(
                    OpenFgaApiBase._process_nested_types(c.strip())
                    for c in content.split(",")
                )

            if container == "set":
                return set(
                    OpenFgaApiBase._process_nested_types(c.strip())
                    for c in content.split(",")
                )

        except Exception as e:
            logger.debug(f"Failed to parse type string `{type_str}`: {e}")
            return type_str

        return type_str

    @staticmethod
    @functools.lru_cache()
    def _deserialize_primitive(data: Any, response_class: type) -> Any:
        """
        Deserialize primitive types (int, float, str, bool, etc.).
        """
        try:
            return (
                response_class(data) if not isinstance(data, response_class) else data
            )
        except (ValueError, TypeError):
            logger.debug(
                f"Failed to cast `{data}` to `{response_class.__name__}`. Returning raw data."
            )
            return data

    @staticmethod
    @functools.lru_cache()
    def _deserialize_date(string: str) -> datetime.date | str:
        """
        Deserialize a string into a date object.

        Args:
            string (str): The date string to parse.

        Returns:
            datetime.date | str: The parsed date or the raw string if parsing fails.
        """
        try:
            return datetime.datetime.strptime(string, "%Y-%m-%d").date()
        except (ValueError, TypeError) as e:
            logger.warning(f"Failed to parse `{string}` as date: {e}")
            return string

    @staticmethod
    @functools.lru_cache()
    def _deserialize_datetime(string: str) -> datetime.datetime | str:
        """
        Deserialize a string into a datetime object.

        Args:
            string (str): The datetime string to parse.

        Returns:
            datetime.datetime | str: The parsed datetime or the raw string if parsing fails.
        """
        try:
            return datetime.datetime.strptime(string, "%Y-%m-%dT%H:%M:%S.%fZ")
        except ValueError:
            try:
                return parse(string, fuzzy=False)
            except (ValueError, TypeError) as e:
                logger.warning(f"Failed to parse `{string}` as datetime: {e}")
                return string
