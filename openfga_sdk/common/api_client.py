"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

import atexit
import datetime

from dataclasses import dataclass, field
from multiprocessing.pool import ThreadPool
from openfga_sdk.common.cookies import HttpCookies
from openfga_sdk.common.factory import FactoryConsumer
from openfga_sdk.common.headers import HttpHeaders
from openfga_sdk.common.math import Math
from openfga_sdk.exceptions import (
    RateLimitExceededError,
    ServiceException,
)
from openfga_sdk.protocols import (
    ApiClientResponseProtocol,
    ConfigurationProtocol,
    FactoryProtocol,
    ApiClientProtocol,
    HttpHeadersProtocol,
    HttpCookiesProtocol,
    MergeableDataclassMixin,
    RestClientRequestProtocol,
    RestClientResponseProtocol,
)


@dataclass
class ApiClientResponse(MergeableDataclassMixin, ApiClientResponseProtocol):
    retries: int = 0
    exception: Exception | None = None
    request: RestClientRequestProtocol | None = None
    response: RestClientResponseProtocol | None = None

    @property
    def status(self) -> int | None:
        if self.response:
            return self.response.status


@dataclass
class ApiClientBase(FactoryConsumer, ApiClientProtocol):
    configuration: ConfigurationProtocol
    factory: FactoryProtocol | None = None
    headers: HttpHeadersProtocol | None = field(default_factory=HttpHeaders)
    cookies: HttpCookiesProtocol | None = field(default_factory=HttpCookies)
    pool_threads: int = 1
    user_agent: str | None = None
    pool: ThreadPool | None = None

    DEFAULT_USER_AGENT = "openfga-sdk python/0.9.1"

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)

    NATIVE_TYPES_MAPPING = {
        "int": int,
        "long": int,
        "float": float,
        "str": str,
        "bool": bool,
        "date": datetime.date,
        "datetime": datetime.datetime,
        "object": object,
    }

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def close(self):
        if self.pool:
            self.pool.close()
            self.pool.join()
            self.pool = None

            if hasattr(atexit, "unregister") and callable(atexit.unregister):
                atexit.unregister(self.close)

    @property
    def _pool(self) -> ThreadPool:
        if self.pool is None:
            atexit.register(self.close)
            self.pool = ThreadPool(self.pool_threads)

        return self.pool

    def _should_retry(
        self,
        response_status: int,
        retry: int,
        max_retries: int,
        min_wait: int,
        e: Exception | None = None,
    ) -> int | None:
        if e is None or not e in [RateLimitExceededError, ServiceException]:
            return None

        if response_status == 501:
            return None

        if retry == max_retries:
            return None

        return Math.jitter(retry, min_wait)

    def _handle_exception(
        self,
        e: Exception | None = None,
        response_type: tuple[int, str] | None = None,
    ) -> None:
        if e is None:
            return

        if response_type is not None:
            raise e
