"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

from dataclasses import asdict, dataclass, field
from enum import Enum
import json
import logging
import socket
import ssl

from typing import Any, Protocol
from urllib.parse import urlencode

from attr import fields

from openfga_sdk.common.headers import HttpHeaderKeys, HttpHeaders
from openfga_sdk.exceptions import (
    ApiException,
    ApiValueError,
    ForbiddenException,
    NotFoundException,
    RateLimitExceededError,
    ServiceException,
    UnauthorizedException,
    ValidationException,
)
from openfga_sdk.protocols import (
    HttpHeadersProtocol,
    MergeableDataclassMixin,
    RestClientProtocol,
    RestClientRequestBodyProtocol,
    RestClientRequestFieldParameterProtocol,
    RestClientRequestFieldParametersProtocol,
    RestClientRequestProtocol,
    RestClientRequestQueryParameterProtocol,
    RestClientRequestQueryParametersProtocol,
    RestClientResponseProtocol,
    StoreRequestOptionsProtocol,
)


logger = logging.getLogger(__name__)


class RestClientRequestMethod(Enum):
    GET = "GET"
    HEAD = "HEAD"
    DELETE = "DELETE"
    POST = "POST"
    PUT = "PUT"
    PATCH = "PATCH"
    OPTIONS = "OPTIONS"


class RestClientRequestContentType(Enum):
    JSON = "application/json"
    FORM_ENCODED = "application/x-www-form-urlencoded"
    FORM_MULTIPART = "multipart/form-data"


@dataclass
class RestClientRequestQueryParameter(RestClientRequestQueryParameterProtocol):
    name: str
    value: str

    def __str__(self) -> str:
        return f"{self.name}: {self.value}"


@dataclass
class RestClientRequestQueryParameters(
    MergeableDataclassMixin, RestClientRequestQueryParametersProtocol
):
    parameters: dict[str, RestClientRequestQueryParameterProtocol] = field(
        default_factory=dict
    )

    def add_parameter(self, name: str, value: str, **kwargs) -> None:
        self.parameters[name] = RestClientRequestQueryParameter(
            name=name, value=value, **kwargs
        )

    def get_parameter(
        self, name: str
    ) -> RestClientRequestQueryParameterProtocol | None:
        return self.parameters.get(name)

    def remove_parameter(self, name: str) -> None:
        self.parameters.pop(name, None)

    def merge(self, other: "RestClientRequestQueryParametersProtocol") -> None:
        for name, params_list in other.parameters.items():
            if name in self.parameters:
                self.parameters[name].extend(params_list)
            else:
                self.parameters[name] = params_list.copy()

    def urlencode(self, prefix: str | None = None) -> str:
        encoded = urlencode(dict(self.parameters))

        if prefix is not None:
            return f"{prefix}?{encoded}"

        return encoded

    def as_dict(self) -> dict[str, str]:
        return {name: value.value for name, value in self.parameters.items()}

    def __getitem__(self, name: str) -> RestClientRequestQueryParameterProtocol | None:
        return self.get_parameter(name)

    def __setitem__(
        self, name: str, value: RestClientRequestQueryParameterProtocol
    ) -> None:
        self.parameters[name] = value

    def __delitem__(self, name: str) -> None:
        self.remove_parameter(name)

    def __contains__(self, name: str) -> bool:
        return name in self.parameters

    def __iter__(self):
        return iter(self.parameters)

    def items(self):
        return self.parameters.items()

    def __str__(self) -> str:
        return "\n".join(str(parameter) for parameter in self.parameters.values())

    @staticmethod
    def from_options(
        options: StoreRequestOptionsProtocol | None,
    ) -> "RestClientRequestQueryParametersProtocol":
        params = RestClientRequestQueryParameters()

        if options is None:
            return params

        if hasattr(options, "page_size") and options.page_size is not None:
            params.add_parameter("page_size", str(options.page_size))

        if (
            hasattr(options, "continuation_token")
            and options.continuation_token is not None
        ):
            params.add_parameter("continuation_token", options.continuation_token)

        return params


@dataclass
class RestClientRequestFieldParameter(RestClientRequestFieldParameterProtocol):
    name: str
    value: str

    def __str__(self) -> str:
        return f"{self.name}: {self.value}"


@dataclass
class RestClientRequestFieldParameters(
    MergeableDataclassMixin, RestClientRequestFieldParametersProtocol
):
    parameters: dict[str, RestClientRequestFieldParameterProtocol] = field(
        default_factory=dict
    )

    def add_parameter(self, name: str, value: str, **kwargs) -> None:
        self.parameters[name] = RestClientRequestFieldParameter(
            name=name, value=value, **kwargs
        )

    def get_parameter(
        self, name: str
    ) -> RestClientRequestFieldParameterProtocol | None:
        return self.parameters.get(name)

    def remove_parameter(self, name: str) -> None:
        self.parameters.pop(name, None)

    def merge(self, other: "RestClientRequestFieldParametersProtocol") -> None:
        for name, params_list in other.parameters.items():
            if name in self.parameters:
                self.parameters[name].extend(params_list)
            else:
                self.parameters[name] = params_list.copy()

    def as_dict(self) -> dict[str, str]:
        return {name: value.value for name, value in self.parameters.items()}

    def __getitem__(self, name: str) -> RestClientRequestFieldParameterProtocol | None:
        return self.get_parameter(name)

    def __setitem__(
        self, name: str, value: RestClientRequestFieldParameterProtocol
    ) -> None:
        self.parameters[name] = value

    def __delitem__(self, name: str) -> None:
        self.remove_parameter(name)

    def __contains__(self, name: str) -> bool:
        return name in self.parameters

    def __iter__(self):
        return iter(self.parameters)

    def items(self):
        return self.parameters.items()

    def __str__(self) -> str:
        return "\n".join(str(parameter) for parameter in self.parameters.values())


@dataclass
class RestClientRequestBody(RestClientRequestBodyProtocol):
    value: str = ""

    def __str__(self) -> str:
        return f"{self.value}"


@dataclass
class RestClientRequest(RestClientRequestProtocol):
    pass


class RestClientBase(RestClientProtocol):
    _ssl_context: ssl.SSLContext | None = None
    _pool_size_max: int | None = None
    _pool_size: int | None = None
    _debug: bool | None = None

    @property
    def ssl_context(self) -> ssl.SSLContext:
        """
        Returns a configured SSLContext.
        """
        if self._ssl_context is None:
            context = ssl.create_default_context()

            if type(context) is not ssl.SSLContext:
                raise TypeError("Unable to create SSLContext")

            if self._configuration.ssl_ca_cert:
                context.load_verify_locations(cafile=self._configuration.ssl_ca_cert)

            if self._configuration.cert_file:
                context.load_cert_chain(
                    self._configuration.cert_file, keyfile=self._configuration.key_file
                )

            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            # if self._configuration.verify_ssl:
            #     context.verify_mode = ssl.CERT_REQUIRED

            #     if not self._configuration.assert_hostname:
            #         context.check_hostname = True

            self._ssl_context = context

        return self._ssl_context

    @property
    def debug(self) -> bool:
        return self._debug or self._configuration.debug

    @debug.setter
    def debug(self, value: bool | None) -> None:
        self._debug = value

    @staticmethod
    def build_request(
        method: RestClientRequestMethod,
        url: str,
        body: RestClientRequestBodyProtocol | None = None,
        headers: HttpHeadersProtocol | None = None,
        query: RestClientRequestQueryParametersProtocol | None = None,
        fields: RestClientRequestFieldParametersProtocol | None = None,
    ) -> RestClientRequestProtocol:
        query = RestClientRequestQueryParameters() | query
        fields = RestClientRequestFieldParameters() | fields
        headers = HttpHeaders() | headers
        data: str | None = None
        multipart: bool | None = None

        if headers.get_header(HttpHeaderKeys.CONTENT_TYPE.value) == []:
            headers.add_header(
                HttpHeaderKeys.CONTENT_TYPE.value,
                RestClientRequestContentType.JSON.value,
            )

        if query:
            url = query.urlencode(url)

        if method in [
            RestClientRequestMethod.POST,
            RestClientRequestMethod.PUT,
            RestClientRequestMethod.PATCH,
            RestClientRequestMethod.OPTIONS,
            RestClientRequestMethod.DELETE,
        ]:
            content_type = headers.get_header(HttpHeaderKeys.CONTENT_TYPE.value)
            content_type = content_type[0] if content_type != [] else None

            match content_type:
                case RestClientRequestContentType.JSON.value:
                    if body is not None:
                        data = json.dumps(body)
                    else:
                        data = json.dumps({})

                case RestClientRequestContentType.FORM_ENCODED.value:
                    multipart = False

                case RestClientRequestContentType.FORM_MULTIPART.value:
                    headers.remove_header(HttpHeaderKeys.CONTENT_TYPE.value)
                    multipart = True

                case _:
                    if isinstance(body, bytes):
                        data = body.decode("utf-8")
                    else:
                        raise ApiException(
                            status=0,
                            reason=(
                                "Cannot prepare a request message for provided arguments. "
                                "Please check that your arguments match declared content type."
                            ),
                        )

        return RestClientRequest(
            method=str(method.value),
            url=url,
            body=data,
            fields=fields.as_dict(),
            headers=headers.as_dict(),
            multipart=multipart,
        )

    def _log_response(self, response: RestClientResponseProtocol) -> None:
        if self.debug:
            logger.debug("response body: %s", response.data.decode("utf-8"))

    def _handle_response_exception(self, response: RestClientResponseProtocol) -> None:
        """
        Raises exceptions if response status indicates an error.

        :param response: The response to check.
        :raises ValidationException: If status is 400.
        :raises UnauthorizedException: If status is 401.
        :raises ForbiddenException: If status is 403.
        :raises NotFoundException: If status is 404.
        :raises RateLimitExceededError: If status is 429.
        :raises ServiceException: If status is 5xx.
        :raises ApiException: For other non-2xx statuses.
        """
        if 200 <= response.status <= 299:
            return

        match response.status:
            case 400:
                raise ValidationException(http_resp=response)
            case 401:
                raise UnauthorizedException(http_resp=response)
            case 403:
                raise ForbiddenException(http_resp=response)
            case 404:
                raise NotFoundException(http_resp=response)
            case 429:
                raise RateLimitExceededError(http_resp=response)
            case _ if 500 <= response.status <= 599:
                raise ServiceException(http_resp=response)
            case _:
                raise ApiException(http_resp=response)

    def _accumulate_json_lines(
        self, leftover: bytes, data: bytes, buffer: bytearray
    ) -> tuple[bytes, list[Any]]:
        """
        Processes a chunk of data and leftover bytes. Splits on newlines, decodes valid JSON,
        and returns leftover bytes and a list of decoded JSON objects.

        :param leftover: Any leftover bytes from previous chunks.
        :param data: The new chunk of data.
        :param buffer: The main bytearray buffer for all data.
        :return: Updated leftover bytes and a list of decoded JSON objects.
        """

        objects: list[Any] = []
        leftover += data
        lines = leftover.split(
            b"\n"
        )  # Objects are received as one-per-line, so split at newlines
        leftover = lines.pop()
        buffer.extend(data)
        for line in lines:
            try:
                decoded = json.loads(line.decode("utf-8"))
                objects.append(decoded)
            except json.JSONDecodeError as e:
                logger.warning("Skipping invalid JSON segment: %s", e)

        return leftover, objects
