"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

from dataclasses import dataclass, field
import http
import logging
import sys

from typing import Any
from urllib.parse import urlparse, urlunparse

from openfga_sdk.exceptions import FgaValidationException
from openfga_sdk.protocols import (
    ConfigurationDataProtocol,
    ConfigurationProtocol,
    CredentialsProtocol,
    RetryParamsProtocol,
    TelemetryConfigurationProtocol,
)
from openfga_sdk.telemetry.attributes import TelemetryAttribute
from openfga_sdk.telemetry.configuration import (
    TelemetryConfiguration,
    TelemetryConfigurationType,
    TelemetryMetricConfiguration,
    TelemetryMetricsConfiguration,
)
from openfga_sdk.telemetry.counters import TelemetryCounter
from openfga_sdk.telemetry.histograms import TelemetryHistogram
from openfga_sdk.validation import (
    ValidatedInteger,
    is_well_formed_ulid_string,
)


@dataclass
class RetryParams(RetryParamsProtocol):
    max_retries: ValidatedInteger = ValidatedInteger(
        value=RetryParamsProtocol.DEFAULT_MAX_RETRIES, min=0, max=15
    )
    min_wait_in_ms: ValidatedInteger = ValidatedInteger(
        value=RetryParamsProtocol.DEFAULT_MIN_WAIT, min=0, max=1000
    )


@dataclass
class ConfigurationData(ConfigurationDataProtocol):
    api_key_prefix: dict[str, bool | int | str] = field(default_factory=dict)
    api_key: dict[str, bool | int | str] = field(default_factory=dict)
    api_url: str | None = None
    assert_hostname: str | None = None
    cert_file: str | None = None
    client_side_validation: bool = True
    connection_pool_size: int = 4
    connection_pool_size_max: int = 100
    credentials: CredentialsProtocol | None = None
    debug: bool = False
    discard_unknown_keys: bool = False
    key_file: str | None = None
    logger_file_handler: logging.FileHandler | None = None
    logger_file: str | None = None
    logger_format = "%(asctime)s %(levelname)s %(message)s"
    logger_formatter: logging.Formatter | None = None
    logger: dict[str, logging.Logger] = field(default_factory=dict)
    password: str | None = None
    proxy_headers: dict[str, str] | None = field(default_factory=dict)
    proxy: str | None = None
    retry_params: RetryParamsProtocol = field(default_factory=lambda: RetryParams())
    socket_options: list[tuple[int, int, int | bytes]] | None = None
    ssl_ca_cert: str | None = None
    store_id: str | None = None
    authorization_model_id: str | None = None
    telemetry: TelemetryConfigurationProtocol = field(
        default_factory=lambda: TelemetryConfiguration.withDefaults()
    )
    timeout: int = 300000
    username: str | None = None
    verify_ssl: bool = True


class Configuration(ConfigurationProtocol):
    """
    OpenFGA configuration
    """

    _data: ConfigurationData

    def __init__(
        self,
        api_url: str,
        store_id: str | None = None,
        authorization_model_id: str | None = None,
        credentials: CredentialsProtocol | None = None,
        retry_params: RetryParamsProtocol | None = None,
        api_key: dict[str, bool | int | str] = {},
        api_key_prefix: dict[str, bool | int | str] = {},
        username: str | None = None,
        password: str | None = None,
        discard_unknown_keys: bool = False,
        ssl_ca_cert: str | None = None,
        telemetry: (
            TelemetryConfigurationProtocol
            | dict[
                TelemetryConfigurationType | str,
                TelemetryMetricsConfiguration
                | dict[
                    TelemetryHistogram | TelemetryCounter | str,
                    TelemetryMetricConfiguration
                    | dict[TelemetryAttribute | str, bool]
                    | None,
                ]
                | None,
            ]
            | None
        ) = None,
        timeout: int = 300000,
    ):
        self._data = ConfigurationData()

        self.api_url = api_url
        self.store_id = store_id
        self.authorization_model_id = authorization_model_id
        self.credentials = credentials
        self.api_key = api_key
        self.api_key_prefix = api_key_prefix
        self.username = username
        self.password = password
        self.discard_unknown_keys = discard_unknown_keys
        self.ssl_ca_cert = ssl_ca_cert
        self.timeout = timeout

        if retry_params is not None:
            self.retry_params = retry_params

        if telemetry is not None:
            self.telemetry = self._telemetry_from_config(telemetry)

    @classmethod
    def get_default_copy(cls) -> ConfigurationData:
        return ConfigurationData()

    def get(self, key: str) -> Any:
        return getattr(self._data, key)

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        return auth

    def to_debug_report(self) -> str:
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return (
            "Python SDK Debug Report:\n"
            f"OS: {sys.platform}\n"
            f"Python Version: {sys.version}\n"
            "Version of the API: 1.x\n"
            "SDK Package Version: 0.9.1"
        )

    def is_valid(self) -> bool:
        """
        Verify the configuration is valid.
        Note that we are only doing basic validation to ensure input is sane.
        """
        return True

    def _url_with_scheme(self, value: str) -> str:
        if value.startswith("http://") or value.startswith("https://"):
            return value

        return f"https://{value}"

    def _telemetry_from_config(
        self,
        value: (
            TelemetryConfigurationProtocol
            | dict[
                TelemetryConfigurationType | str,
                TelemetryMetricsConfiguration
                | dict[
                    TelemetryHistogram | TelemetryCounter | str,
                    TelemetryMetricConfiguration
                    | dict[TelemetryAttribute | str, bool]
                    | None,
                ]
                | None,
            ]
            | None
        ) = None,
    ) -> TelemetryConfigurationProtocol:
        """
        Create a TelemetryConfiguration from a dictionary.
        """
        if isinstance(value, TelemetryConfigurationProtocol):
            return value

        if isinstance(value, dict):
            return TelemetryConfiguration(value)

        return TelemetryConfiguration.withDefaults()

    @property
    def api_key_prefix(self) -> dict[str, bool | int | str]:
        return self._data.api_key_prefix

    @api_key_prefix.setter
    def api_key_prefix(self, value: dict[str, bool | int | str]):
        self._data.api_key_prefix = value

    @property
    def api_key(self) -> dict[str, bool | int | str]:
        return self._data.api_key

    @api_key.setter
    def api_key(self, value: dict[str, bool | int | str]):
        self._data.api_key = value

    @property
    def api_url(self) -> str:
        return self._data.api_url or ""

    @api_url.setter
    def api_url(self, value: str) -> None:
        _url = None

        try:
            _url = urlparse(
                self._url_with_scheme(value), scheme="https", allow_fragments=False
            )
        except Exception:
            raise FgaValidationException(f"api_url `{value}` is invalid")

        if _url.scheme not in ["http", "https"]:
            raise FgaValidationException(
                f"api_url `{value}` must use either `http` or `https` scheme"
            )

        if _url.hostname is None or _url.hostname == "":
            raise FgaValidationException(
                f"api_url `{value}` must include a valid hostname"
            )

        if _url.path != "":
            raise FgaValidationException(f"api_url `{value}` must not include a path")

        if _url.query != "":
            raise FgaValidationException(f"api_url `{value}` must not include a query")

        if _url.fragment != "":
            raise FgaValidationException(
                f"api_url `{value}` must not include a fragment"
            )

        self._data.api_url = str(urlunparse(_url))

    @property
    def assert_hostname(self) -> str | None:
        """
        When verifying SSL/TLS certificates, the hostname in the certificate is checked against the hostname of the server you are connecting to. If they do not match, the connection is considered insecure. This property allows you to specify the hostname that should be used for this check.
        """
        return self._data.assert_hostname

    @assert_hostname.setter
    def assert_hostname(self, value: str | None):
        """
        When verifying SSL/TLS certificates, the hostname in the certificate is checked against the hostname of the server you are connecting to. If they do not match, the connection is considered insecure. This property allows you to specify the hostname that should be used for this check.
        """
        self._data.assert_hostname = value

    @property
    def authorization_model_id(self) -> str | None:
        return self._data.authorization_model_id

    @authorization_model_id.setter
    def authorization_model_id(self, value: str | None) -> None:
        if value is None or value == "":
            self._data.authorization_model_id = None
            return

        if is_well_formed_ulid_string(value):
            self._data.authorization_model_id = value
            return

        raise FgaValidationException(
            f"authorization_model_id ('{value}') is not in a valid ulid format"
        )

    @property
    def cert_file(self) -> str | None:
        """
        When verifying SSL/TLS certificates, a custom private key (key_file) and corresponding certificate (cert_file) can be specified. This is useful when the server uses a self-signed certificate or a certificate from a non-standard CA.
        """
        return self._data.cert_file

    @cert_file.setter
    def cert_file(self, value: str | None):
        """
        When verifying SSL/TLS certificates, a custom private key (key_file) and corresponding certificate (cert_file) can be specified. This is useful when the server uses a self-signed certificate or a certificate from a non-standard CA.
        """
        self._data.cert_file = value

    @property
    def client_side_validation(self) -> bool:
        return self._data.client_side_validation

    @client_side_validation.setter
    def client_side_validation(self, value: bool):
        self._data.client_side_validation = value

    @property
    def connection_pool_size(self) -> int:
        return self._data.connection_pool_size

    @connection_pool_size.setter
    def connection_pool_size(self, value: int):
        if value < 1:
            raise FgaValidationException(
                f"connection_pool_size must be greater than or equal to 1, {value}"
            )

        self._data.connection_pool_size = value

    @property
    def connection_pool_size_max(self) -> int:
        return self._data.connection_pool_size_max

    @connection_pool_size_max.setter
    def connection_pool_size_max(self, value: int):
        if value < 1:
            raise FgaValidationException(
                f"connection_pool_size_max must be greater than or equal to 1, {value}"
            )

        self._data.connection_pool_size_max = value

    @property
    def credentials(self) -> CredentialsProtocol | None:
        return self._data.credentials

    @credentials.setter
    def credentials(self, value: CredentialsProtocol | None):
        if value is not None:
            value.validate()

        self._data.credentials = value

    @property
    def debug(self) -> bool:
        return self._data.debug

    @debug.setter
    def debug(self, value: bool) -> None:
        self._data.debug = value

        _loggerLevel = logging.DEBUG if self._data.debug else logging.WARNING
        _httpDebugLevel = 1 if self._data.debug else 0

        for _, logger in self.logger.items():
            logger.setLevel(_loggerLevel)

        http.client.HTTPConnection.set_debuglevel(
            http.client.HTTPConnection, _httpDebugLevel
        )

    @property
    def discard_unknown_keys(self) -> bool:
        return self._data.discard_unknown_keys

    @discard_unknown_keys.setter
    def discard_unknown_keys(self, value: bool) -> None:
        self._data.discard_unknown_keys = value

    @property
    def key_file(self) -> str | None:
        """
        When verifying SSL/TLS certificates, a custom private key (key_file) and corresponding certificate (cert_file) can be specified. This is useful when the server uses a self-signed certificate or a certificate from a non-standard CA.
        """
        return self._data.key_file

    @key_file.setter
    def key_file(self, value: str | None):
        """
        When verifying SSL/TLS certificates, a custom private key (key_file) and corresponding certificate (cert_file) can be specified. This is useful when the server uses a self-signed certificate or a certificate from a non-standard CA.
        """
        self._data.key_file = value

    @property
    def logger_file(self) -> str | None:
        return self._data.logger_file

    @logger_file.setter
    def logger_file(self, value: str | None) -> None:
        if self._data.logger_file_handler is not None:
            for _, logger in self.logger.items():
                logger.removeHandler(self._data.logger_file_handler)

            self._data.logger_file_handler = None

        if type(value) is str and value == "":
            value = None

        self._data.logger_file = value

        if self._data.logger_file is not None:
            self._data.logger_file_handler = logging.FileHandler(self._data.logger_file)
            self._data.logger_file_handler.setFormatter(self._data.logger_formatter)

            for _, logger in self.logger.items():
                logger.addHandler(self._data.logger_file_handler)

    @property
    def logger_format(self) -> str:
        return self._data.logger_format

    @logger_format.setter
    def logger_format(self, value: str) -> None:
        self._data.logger_format = value
        self._data.logger_formatter = logging.Formatter(self._data.logger_format)

    @property
    def logger(self) -> dict[str, logging.Logger]:
        """
        Return configured loggers
        """
        if self._data.logger is None:
            self._data.logger = {
                "package_logger": logging.getLogger("openfga_sdk"),
                "urllib3_logger": logging.getLogger("urllib3"),
            }

        return self._data.logger

    @logger.setter
    def logger(self, value: dict[str, logging.Logger]) -> None:
        """
        Update configured loggers
        """
        self._data.logger = value

    @property
    def password(self) -> str | None:
        return self._data.password

    @password.setter
    def password(self, value: str | None) -> None:
        self._data.password = value

    @property
    def proxy_headers(self) -> dict[str, str] | None:
        """
        A dictionary containing headers that will be sent to the proxy.
        """
        return self._data.proxy_headers

    @proxy_headers.setter
    def proxy_headers(self, value: dict[str, str] | None) -> None:
        """
        A dictionary containing headers that will be sent to the proxy.
        """
        self._data.proxy_headers = value

    @property
    def proxy(self) -> dict[str, str] | None:
        """
        The URL of the proxy to be used.
        """
        return self._data.proxy

    @proxy.setter
    def proxy(self, value: dict[str, str] | None) -> None:
        """
        The URL of the proxy to be used.
        """
        self._data.proxy = value

    @property
    def retry_params(self) -> RetryParams:
        return self._data.retry_params

    @retry_params.setter
    def retry_params(self, value: RetryParams) -> None:
        self._data.retry_params = value

    @property
    def socket_options(self) -> list[tuple[int, int, int | bytes]] | None:
        """
        (For urllib3 connections only.) Set specific options on the underlying socket. If not specified, then defaults are loaded from HTTPConnection.default_socket_options.
        """
        return self._data.socket_options

    @socket_options.setter
    def socket_options(self, value: list[tuple[int, int, int | bytes]] | None) -> None:
        """
        (For urllib3 connections only.) Set specific options on the underlying socket. If not specified, then defaults are loaded from HTTPConnection.default_socket_options.
        """
        self._data.socket_options = value

    @property
    def ssl_ca_cert(self) -> str | None:
        """
        Returns the path of the configured certificate authority bundle.
        """
        return self._data.ssl_ca_cert

    @ssl_ca_cert.setter
    def ssl_ca_cert(self, value: str | None) -> None:
        """
        Configure a custom certificate authority bundle using a file system path.
        """
        self._data.ssl_ca_cert = value

    @property
    def store_id(self) -> str | None:
        return self._data.store_id

    @store_id.setter
    def store_id(self, value: str | None) -> None:
        if value is not None:
            value = value.strip()

        if value is None or value == "":
            self._data.store_id = None
            return

        if not is_well_formed_ulid_string(value):
            raise FgaValidationException(
                f"store_id ('{value}') is not in a valid ulid format"
            )

        self._data.store_id = value

    @property
    def telemetry(self) -> TelemetryConfigurationProtocol:
        return self._data.telemetry

    @telemetry.setter
    def telemetry(self, value: TelemetryConfigurationProtocol) -> None:
        self._data.telemetry = value

    @property
    def timeout(self) -> int:
        return self._data.timeout

    @timeout.setter
    def timeout(self, value: int) -> None:
        if value < 0 or value > 600000:
            raise FgaValidationException(
                f"timeout not within reasonable range (0,60000), {value}"
            )

        self._data.timeout = value

    @property
    def username(self) -> str | None:
        return self._data.username

    @username.setter
    def username(self, value: str | None) -> None:
        self._data.username = value

    @property
    def verify_ssl(self) -> bool:
        return self._data.verify_ssl

    @verify_ssl.setter
    def verify_ssl(self, value: bool) -> None:
        self._data.verify_ssl = value
