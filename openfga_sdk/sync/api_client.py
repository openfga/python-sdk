"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

from dataclasses import dataclass
import datetime
import json
import re
import time

from dateutil.parser import parse  # type: ignore[import-untyped]

from openfga_sdk.common.api_client import ApiClientBase, ApiClientResponse
from openfga_sdk.common.cookies import HttpCookies
from openfga_sdk.common.headers import HttpHeaders
from openfga_sdk.common.math import Math
from openfga_sdk.common.rest import (
    RestClientRequestBody,
    RestClientRequestFieldParameters,
    RestClientRequestMethod,
    RestClientRequestQueryParameters,
)
import openfga_sdk.models

from openfga_sdk.configuration import Configuration
from openfga_sdk.exceptions import (
    ApiException,
    ApiValueError,
    FgaValidationException,
)
from openfga_sdk.protocols import (
    FactoryProtocol,
    HttpCookiesProtocol,
    HttpHeadersProtocol,
    RestClientRequestBodyProtocol,
    RestClientRequestFieldParametersProtocol,
    RestClientRequestQueryParametersProtocol,
    RetryParamsProtocol,
    TelemetryAttributeProtocol,
)
from openfga_sdk.sync import oauth2
from openfga_sdk.sync.rest import RestClient
from openfga_sdk.telemetry.attributes import TelemetryAttribute, TelemetryAttributes


class ApiClient(ApiClientBase):
    @property
    def _factory(self) -> FactoryProtocol:
        if self.factory is None:
            return self._factory_sync

        return self.factory

    def request(
        self,
        path: str,
        method: RestClientRequestMethod,
        body: RestClientRequestBodyProtocol | None = None,
        headers: HttpHeadersProtocol | None = None,
        query: RestClientRequestQueryParametersProtocol | None = None,
        fields: RestClientRequestFieldParametersProtocol | None = None,
        cookies: HttpCookiesProtocol | None = None,
        timeout: int | None = None,
        response_types: list[tuple[int, str]] | None = None,
        attributes: (
            dict[TelemetryAttributeProtocol, str | bool | int | float] | None
        ) = None,
        streaming: bool = False,
    ) -> ApiClientResponse:
        start = float(time.time())

        # Assemble request URL
        url = self.configuration.api_url + path

        # Prepare query parameters
        query: RestClientRequestQueryParameters = (
            query or RestClientRequestQueryParameters()
        )

        # Prepare POST parameters
        fields: RestClientRequestFieldParameters = (
            fields or RestClientRequestFieldParameters()
        )

        # Prepare request body
        body: RestClientRequestBody = body or RestClientRequestBody()

        # Prepare response type map
        response_types: tuple[int, str] = response_types or ()

        # Prepare telemetry attributes
        attributes: dict[TelemetryAttribute, str | bool | int | float] = (
            attributes or {}
        )

        # Prepare cookies
        cookies: HttpCookies = cookies or HttpCookies()
        cookies.merge(self.cookies)

        # Prepare headers
        headers: HttpHeaders = headers or HttpHeaders()
        headers.merge(self.headers)

        # Add cookie headers to the request, if any
        if cookies:
            headers.add_header("Cookie", cookies.as_header())

        # Perform credentials exchange if necessary
        if (
            self.configuration.credentials is not None
            and self.configuration.credentials.method == "client_credentials"
        ):
            headers.insert_header(
                self.auth_client.get_authentication_header(self.rest_client)
            )

        # Collect automatic retry conditions
        max_retries = (
            self.configuration.retry_params.max_retries
            or RetryParamsProtocol.DEFAULT_MAX_RETRIES
        )

        min_wait_in_ms = (
            self.configuration.retry_params.min_wait_in_ms
            or RetryParamsProtocol.DEFAULT_MIN_WAIT
        )

        # Build the request object
        request = self.rest_client.build_request(
            method=method,
            url=url,
            body=body,
            headers=headers,
            query=query,
            fields=fields,
        )

        # Seed the telemetry attributes with the request data
        attributes = TelemetryAttributes.fromRequest(
            user_agent=self.user_agent,
            fga_method=path,
            http_method=method,
            url=url,
            resend_count=0,
            start=start,
            credentials=self.configuration.credentials,
            attributes=attributes,
        )

        for retry in range(max_retries + 1):
            attributes[TelemetryAttributes.http_request_resend_count] = retry
            exception: Exception | None = None

            try:
                response = (
                    self.rest_client.request(request)
                    if not streaming
                    else self.rest_client.stream(request)
                )
            except Exception as e:
                exception = e

            response_status: int = (
                exception.status
                if exception is not None
                else response.status if response is not None else 500
            )

            retry_delay: int | None = self._should_retry(
                retry=retry,
                max_retries=max_retries,
                min_wait=min_wait_in_ms,
                e=exception,
                response_status=response_status,
            )

            # Update telemetry attributes with response data, if available
            attributes = TelemetryAttributes.fromResponse(
                response=response,
                credentials=self.configuration.credentials,
                attributes=attributes,
            )

            self.telemetry_client.metrics.request(
                attributes=attributes,
                configuration=self.configuration.telemetry,
            )

            self.telemetry_client.metrics.queryDuration(
                attributes=attributes,
                configuration=self.configuration.telemetry,
            )

            self.telemetry_client.metrics.requestDuration(
                attributes=attributes,
                configuration=self.configuration.telemetry,
            )

            if retry_delay is not None:
                time.sleep(retry_delay)
                continue

            response_type: str | None = next(
                (value for code, value in response_types if code == response_status),
                None,
            )

            response_wrapper = ApiClientResponse(
                status=response_status,
                retries=retry,
                request=request,
                response=response,
            )

            if response_type:
                response_wrapper.deserialized = self.deserialize(
                    response, response_type
                )

            return response_wrapper

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]
        elif isinstance(obj, tuple):
            return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)
        elif isinstance(obj, datetime.datetime | datetime.date):
            return obj.isoformat()

        if isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes `openapi_types`, `attribute_map`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = {
                obj.attribute_map[attr]: getattr(obj, attr)
                for attr, _ in obj.openapi_types.items()
                if getattr(obj, attr) is not None
            }

        return {
            key: self.sanitize_for_serialization(val) for key, val in obj_dict.items()
        }

    def deserialize(self, response, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """

        # fetch data from response object
        try:
            data = json.loads(response.data)
        except ValueError:
            data = response.data

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if type(klass) is str:
            if klass.startswith("list["):
                sub_kls = re.match(r"list\[(.*)\]", klass).group(1)
                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]

            if klass.startswith("dict["):
                sub_kls = re.match(r"dict\[([^,]*), (.*)\]", klass).group(2)
                return {k: self.__deserialize(v, sub_kls) for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(openfga_sdk.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)

        if klass is object:
            return self.__deserialize_object(data)

        if klass is datetime.date:
            return self.__deserialize_date(data)

        if klass is datetime.datetime:
            return self.__deserialize_datetime(data)

        return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == "multi":
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == "ssv":
                        delimiter = " "
                    elif collection_format == "tsv":
                        delimiter = "\t"
                    elif collection_format == "pipes":
                        delimiter = "|"
                    else:  # csv is the default
                        delimiter = ","
                    new_params.append((k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def select_header_accept(self, accepts):
        """Returns `Accept` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return

        accepts = [x.lower() for x in accepts]

        if "application/json" in accepts:
            return "application/json"
        else:
            return ", ".join(accepts)

    def select_header_content_type(self, content_types, method=None, body=None):
        """Returns `Content-Type` based on an array of content_types provided.

        :param content_types: List of content-types.
        :param method: http method (e.g. POST, PATCH).
        :param body: http body to send.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        content_types = [x.lower() for x in content_types]

        if (
            method == "PATCH"
            and "application/json-patch+json" in content_types
            and isinstance(body, list)
        ):
            return "application/json-patch+json"

        if "application/json" in content_types or "*/*" in content_types:
            return "application/json"
        else:
            return content_types[0]

    def update_params_for_auth(
        self, headers, queries, auth_settings, request_auth=None, oauth2_client=None
    ):
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        :param oauth2_client: if set, will be used for credential exchange.
        """
        credentials = self.configuration.credentials
        if credentials is not None:
            if credentials.method == "none":
                pass
            if credentials.method == "api_token":
                headers["Authorization"] = (
                    f"Bearer {credentials.configuration.api_token}"
                )
            if credentials.method == "client_credentials":
                if oauth2_client is None:
                    oauth2_client = oauth2.OAuth2Client(credentials, self.configuration)
                oauth2_headers = oauth2_client.get_authentication_header(
                    self.rest_client
                )
                for key, value in oauth2_headers.items():
                    headers[key] = value

        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(headers, queries, request_auth)
            return

        for auth in auth_settings:
            auth_setting = self.configuration.auth_settings().get(auth)
            if auth_setting:
                self._apply_auth_params(headers, queries, auth_setting)

    def _apply_auth_params(self, headers, queries, auth_setting):
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting["in"] == "cookie":
            headers["Cookie"] = auth_setting["value"]
        elif auth_setting["in"] == "header":
            headers[auth_setting["key"]] = auth_setting["value"]
        elif auth_setting["in"] == "query":
            queries.append((auth_setting["key"], auth_setting["value"]))
        else:
            raise ApiValueError("Authentication token must be in `query` or `header`")

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise ApiException(
                status=0, reason=f"Failed to parse `{string}` as date object"
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise ApiException(
                status=0,
                reason=(f"Failed to parse `{string}` as datetime object"),
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """
        has_discriminator = False
        if (
            hasattr(klass, "get_real_child_model")
            and klass.discriminator_value_class_map
        ):
            has_discriminator = True

        if not klass.openapi_types and has_discriminator is False:
            return data

        kwargs = {}
        if (
            data is not None
            and klass.openapi_types is not None
            and isinstance(data, list | dict)
        ):
            for attr, attr_type in klass.openapi_types.items():
                if klass.attribute_map[attr] in data:
                    value = data[klass.attribute_map[attr]]
                    kwargs[attr] = self.__deserialize(value, attr_type)

        kwargs["local_vars_configuration"] = self.configuration
        instance = klass(**kwargs)

        if has_discriminator:
            klass_name = instance.get_real_child_model(data)
            if klass_name:
                instance = self.__deserialize(data, klass_name)
        return instance

    def _get_store_id(self):
        """
        Verify that the store id has been configured and not empty string.
        It will return the store ID.
        Otherwise, raise FgaValidationException
        """
        configuration = self.configuration
        if configuration.store_id is None or configuration.store_id == "":
            raise FgaValidationException("store_id is required but not configured")
        return configuration.store_id

    def set_store_id(self, value):
        """
        Update the store ID in the configuration
        """
        self.configuration.store_id = value

    def get_store_id(self):
        """
        Return the store id (if any) store in the configuration
        """
        return self.configuration.store_id
